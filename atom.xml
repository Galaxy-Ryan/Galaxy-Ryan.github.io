<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>银河的白星</title>
  
  <subtitle>一个不知名的个人博客</subtitle>
  <link href="https://galaxy-ryan.github.io/atom.xml" rel="self"/>
  
  <link href="https://galaxy-ryan.github.io/"/>
  <updated>2024-10-07T15:53:22.383Z</updated>
  <id>https://galaxy-ryan.github.io/</id>
  
  <author>
    <name>Galaxy Ryan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CMU15445-Project2-学习心得与记录</title>
    <link href="https://galaxy-ryan.github.io/article/2024/07/22/15445-p2.html/"/>
    <id>https://galaxy-ryan.github.io/article/2024/07/22/15445-p2.html/</id>
    <published>2024-07-22T15:00:01.000Z</published>
    <updated>2024-10-07T15:53:22.383Z</updated>
    
    <content type="html"><![CDATA[<p>这一部分主要是参考别人的博客进行学习的，需要我们实现 B+ 树索引，主要包括单线程 B+ 树以及多线程下的并发 B+ 树的查询、插入和删除等接口。</p><h2 id="Task1-B-Tree-Pages"><a href="#Task1-B-Tree-Pages" class="headerlink" title="Task1 B+Tree Pages"></a>Task1 B+Tree Pages</h2><p>这个任务主要是让我们了解B+树的<code>Page</code>结构，分为<code>Internal Page</code>和<code>Leaf Page</code>两类。<code>b_plus_tree_page</code>是另外两个<code>page</code>的父类，即 B+ 树中 <strong>tree page</strong> 的抽象。</p><p>首先介绍<code>Internal Page</code>，<code>Internal Page</code>对应 B+ 树中的内部节点，<code>internal page</code>中，<strong>KV</strong> 对的 <em>K</em> 是能够比较大小的索引，<em>V</em> 是 page id，用来指向下一层的节点。在<code>internal page</code>中，n 个 key 可以将数轴划分为 n+1 个区域，也就对应着 n+1 个 value。通过比较 key 的大小选中下一层的节点。</p><p>然后是<code>leaf page</code>，<code>leaf page</code>和<code>internal page</code>的内存布局基本一样，只是 <code>leaf page</code>多了一个成员变量 <code>next_page_id</code>，指向下一个 <code>leaf page</code>（用于 <code>range scan</code>范围扫描）。<code>leaf page</code>的 <strong>KV</strong> 对中，<em>K</em> 是实际的索引，<em>V</em> 是 record id。record id 用于识别表中的某一条数据。<code>leaf page</code>的 <strong>KV</strong> 对是一一对应的，不像<code>internal page</code>的 value 多一个。</p><h2 id="Task2-B-Tree-Data-Structure"><a href="#Task2-B-Tree-Data-Structure" class="headerlink" title="Task2 B+Tree Data Structure"></a>Task2 B+Tree Data Structure</h2><p>这个任务是单线程 B+ 树的重点，需要实现 B+ 树的插入，删除，查找节点操作。</p><p>首先从 <strong>Search</strong> 操作开始，B+ 树的节点分为<code>internal page</code>和<code>leaf page</code>，每个 page 上的 key 有序排列。当拿到一个 key 需要查找对应的 value 时，首先需要经由<code>internal page</code>递归地向下查找，最终找到 key 所在的<code>leaf page</code>，由于 key 是有序的，可以直接进行二分搜索查找。</p><p>对于 <strong>Insert</strong> 操作，我们需要先根据 key 找到需要插入的<code>leaf page</code>，得到<code>leaf page</code>后，将 key 插入<code>leaf page</code>。要注意的是，插入时仍需保证 key 的有序性。同样可以二分搜索找到合适的位置插入。在插入后，需要检查当前 leaf page size 是否等于 max size。若相等，则要进行一次<code>leaf page</code>分裂操作，具体如下：</p><ol><li>新建一个空的 page，</li><li>将原 page 的一半转移到新 page 中，</li><li>更新原 page 和新 page 的 next page id，</li><li>获取 parent page，这里也可能产生分裂，我们需要在插入前检查 parent page size 是否等于 max size，若小于，直接返回 parent page，否则，分裂当前 internal page。并根据此后需要插入的 key 选择分裂后的两个 page 之一作为 parent page 返回。</li><li>将用于区分原 page 和新 page 的 key 插入 parent page 中，</li><li>更新 parent page 所有 child page 的父节点指针。</li></ol><p>另外需要注意一个细节，在<code>leaf page</code>分裂时，向父节点插入 key 时是复制后插入，而<code>internal page</code>分裂时，向父节点插入 key 是删除后插入。</p><p>最后是 <strong>Delete</strong> 操作，同样地，先找到<code>leaf page</code>。删除<code>leaf page</code>中 key 对应的 <strong>KV</strong> 对后，检查 size 是否小于 min size。如果小于的话，首先尝试从两侧的兄弟节点中偷一个 <strong>KV</strong> 对。注意只能从兄弟节点，即父节点相同的节点中选取。假如存在一侧节点有富余的 <strong>KV</strong> 对，则成功偷取，结束操作。若两侧都没有富余的 <strong>KV</strong> 对，则选择一侧节点与其合并。</p><p>偷取的过程比较简单，从左侧节点偷取时，把左侧节点最后一个 <strong>KV</strong> 对转移至当前节点第一个 <strong>KV</strong> 对，从右侧节点偷取时，把右侧节点的 <strong>KV</strong> 对转移至当前节点最后一个 <strong>KV</strong> 对。<code>leaf page</code>和<code>internal page</code>的偷取过程基本相同，仅需注意 <code>internal page</code>偷取后更新子节点的父节点指针。</p><p>稍难的是合并的过程。同样，任选左右侧一兄弟节点进行合并。将一个节点的所有 <strong>KV</strong> 对转移至另一节点。若合并的是<code>leaf page</code>，记得更新<code>next page id</code>。若合并的是<code>internal page</code>，记得更新合并后 page 的子节点的父节点指针。然后，删除 parent 节点中对应的 key。删除后，再次检查 size 是否小于 min size，形成向上递归。当合并<code>leaf page</code>后，简单删除父节点中对应的 key即可。而合并<code>internal page</code>后，并不是简单地删除父节点中对应 key，而是有一个父节点 key 下推的过程。</p><h2 id="Task3-An-Iterator-for-Leaf-Scans"><a href="#Task3-An-Iterator-for-Leaf-Scans" class="headerlink" title="Task3 An Iterator for Leaf Scans"></a>Task3 An Iterator for Leaf Scans</h2><p>这一部分是实现一个遍历<code>leaf page</code>的<a href="https://zhida.zhihu.com/search?q=%E8%BF%AD%E4%BB%A3%E5%99%A8&zhida_source=entity&is_preview=1">迭代器</a>。在迭代器中存储当前<code>leaf page</code>的指针和当前停留的位置即可。遍历完当前 page 后，通过 next page id 找到下一个<code>leaf page</code>。同样，需要 unpin 已经遍历完的 page。</p><h2 id="Task4-Concurrent-Index"><a href="#Task4-Concurrent-Index" class="headerlink" title="Task4 Concurrent Index"></a>Task4 Concurrent Index</h2><p>在这一部分我们需要修改 B+ 树的实现，以支持 B+ 树的并发访问操作，在这里我们就可以用到先前实现的读写页面保护接口来进行页面读写。在实现多线程版本时，可以采用一种特殊的加锁方式<code>latch crabbing</code>，基本思想是： 1. 先锁住 parent page， 2. 再锁住 child page， 3. 假设 child page 是<em>安全</em>的，则释放 parent page 的锁。此外还需要注意：</p><ul><li><code>GetValue</code>：使用读锁，获取子节点的读锁后释放父节点的读锁；</li><li><code>Insert/Remove</code>：如果确认节点不会分裂&#x2F;合并&#x2F;重分配，就将 Context 中存储的父节点都进行释放；</li><li><code>InsertIntoParent/DeleteEntry</code>：因为用到了 Page Guard，而<code>InsertIntoParent</code>又存在<a href="https://zhida.zhihu.com/search?q=%E9%80%92%E5%BD%92&zhida_source=entity&is_preview=1">递归</a>的情况，所以可能会出现 Page Guard 的生命周期在函数递归的全过程中，从而直到完成递归才释放 Page，因此需要在进入下一级递归时，及时释放当前持有的不需要的 Page Guard。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这一部分主要是参考别人的博客进行学习的，需要我们实现 B+ 树索引，主要包括单线程 B+ 树以及多线程下的并发 B+ 树的查询、插入和删除等接口。&lt;/p&gt;
&lt;h2 id=&quot;Task1-B-Tree-Pages&quot;&gt;&lt;a href=&quot;#Task1-B-Tree-Pages&quot; c</summary>
      
    
    
    
    <category term="学习" scheme="https://galaxy-ryan.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="数据库系统" scheme="https://galaxy-ryan.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="优质课程" scheme="https://galaxy-ryan.github.io/tags/%E4%BC%98%E8%B4%A8%E8%AF%BE%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>CMU15445-Project1-学习心得与记录</title>
    <link href="https://galaxy-ryan.github.io/article/2024/07/20/15445-p1.html/"/>
    <id>https://galaxy-ryan.github.io/article/2024/07/20/15445-p1.html/</id>
    <published>2024-07-20T13:29:45.000Z</published>
    <updated>2024-10-07T15:52:04.157Z</updated>
    
    <content type="html"><![CDATA[<h2 id="项目概述"><a href="#项目概述" class="headerlink" title="项目概述"></a>项目概述</h2><p>项目1主要实现<code>Bustub</code>数据库管理系统的存储管理部分(<code>Storage Manager</code>)，我们需要完成存储管理器中缓冲池的管理(<code>BufferPool Manager</code>)、缓冲池中页面的替换算法<code>LRU-K</code>以及处理页面的并发访问控制(<code>Page Guard</code>)。这部分逻辑和内存的管理独立于传统意义上的<code>OS Caching Mechanism</code>，是为了数据库能有比 <em>OS</em> 更加全面的内存管理机制而实现的底层数据结构。因此磁盘上page的读写是交给数据库内核而不是操作系统来做的。</p><h2 id="Task1-LRU-K-页面替换策略"><a href="#Task1-LRU-K-页面替换策略" class="headerlink" title="Task1 LRU-K 页面替换策略"></a>Task1 LRU-K 页面替换策略</h2><p>实现数据库缓冲池的页面换入换出，这里采用的是<code>LRU-K</code>算法，缓冲池里面有多个<code>frame</code>，<code>frame</code>里面存放的就是<code>page</code>，每个<code>frame</code>都维护了一个长度小于等于k的时间戳。</p><p><code>LRU-K</code>算法使用一个参数k，表示要考虑的最近访问记录的数量。它记录每个缓存项最近被访问的k次时间戳，并使用这些时间戳来评估缓存项的重要性。<code>LRU-K</code> 算法移出其向后 k 距离为替换程序中所有帧的最大值的帧。向后 k 距离的计算方法是当前时间戳与第 k 次访问的时间戳之间的时间差。</p><p>具体来说分为下面三个步骤：</p><ol><li><p><strong>访问记录</strong>：每当一个缓存项被访问时，算法会记录下该项的访问时间戳，并更新该项的访问历史。</p></li><li><p><strong>缓存命中与未命中</strong>：</p></li></ol><ul><li><strong>命中</strong>：如果访问的缓存项已经在缓存中，直接返回该项。</li><li><strong>未命中</strong>：如果缓存项不在缓存中，则需要选择一个项进行替换。</li></ul><ol start="3"><li><strong>替换决策</strong>：</li></ol><ul><li>在进行替换时，算法会比较每个缓存项的K次访问时间戳。</li><li>替换策略是选择那些K次访问时间戳最远的缓存项，即最近没有被访问的项。</li></ul><h2 id="Task2-缓冲池管理器"><a href="#Task2-缓冲池管理器" class="headerlink" title="Task2 缓冲池管理器"></a>Task2 缓冲池管理器</h2><p>现在开始实现缓冲池管理器，缓冲池是一个内存区域，用于缓存磁盘上的数据页（数据块）。主要思想是，当数据库需要访问某个数据页时，首先检查该页是否在缓冲池中，即是否访存命中，如果不在，则需要从磁盘读取。</p><p>具体来说<code>BufferpoolManager</code> 维护着数据页（Page）以及帧替换器（Replacer）的数据结构，并通过<code>page_table</code>存放着空闲的<code>frame</code>号以及<code>frameid</code>与<code>pageid</code>的映射关系。以下是各个函数的基本实现思路：</p><ul><li><code>FetchPage(page_id_t page_id)</code>：函数的作用是根据页面ID来获取页面，我们需要处理页面命中和未命中两种情况，首先检查页面是否存在于页表中，如果存在，我们就增加页面的引用计数，并记录帧的访问时间戳。如果不存在，则需要我们检查空闲帧以及替换页。</li><li><code>UnpinPage(page_id_t page_id, bool is_dirty)</code>：函数的作用是取消对页面的固定，允许其被替换。注意要考虑页面ID是否有效以及页面引用计数是否为零等情况。</li><li><code>FlushPage(page_id_t page_id)</code>：函数的作用是将指定页面的内容刷新写回磁盘，比较简单。</li><li><code>NewPage(page_id_t* page_id)</code>：函数的作用是创建一个新页面，并返回该页面的指针和ID。如果没有空闲帧，则尝试通过替换策略获取一个帧。注意如果替换的页为脏页，我们则需要对页面进行刷脏，写回磁盘。</li><li><code>DeletePage(page_id_t page_id)</code>：函数的作用是删除指定页面，我们需要检查页面ID是否在<code>page_table</code>中以及是否被固定，并且需要考虑刷脏、更新页表和空闲帧列表的情况。</li><li><code>FlushAllPages()</code>：函数的作用是刷新所有缓冲池中的页面，确保所有脏页都写回磁盘即可。</li></ul><p>在这里我们为了保证函数逻辑的正确性，可以先将每个函数加上函数作用域的全局锁，后面再进行并发部分的优化。</p><h2 id="Task3-读写页面保护"><a href="#Task3-读写页面保护" class="headerlink" title="Task3 读写页面保护"></a>Task3 读写页面保护</h2><p>这一部分主要是为了解决后续项目开发中页面使用后忘记<code>UnpinPage</code>带来的问题。<code>Page Guard </code>确保在相应对象超出范围时自动解锁页面，同时也简化了P2里B+树的并发实现。作为一个懒人，自己写博客的时间与完成项目的时间有一段距离了，并且这一部分实现不算太难，就不记录思路咯！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;项目概述&quot;&gt;&lt;a href=&quot;#项目概述&quot; class=&quot;headerlink&quot; title=&quot;项目概述&quot;&gt;&lt;/a&gt;项目概述&lt;/h2&gt;&lt;p&gt;项目1主要实现&lt;code&gt;Bustub&lt;/code&gt;数据库管理系统的存储管理部分(&lt;code&gt;Storage Manager</summary>
      
    
    
    
    <category term="学习" scheme="https://galaxy-ryan.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="数据库系统" scheme="https://galaxy-ryan.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="优质课程" scheme="https://galaxy-ryan.github.io/tags/%E4%BC%98%E8%B4%A8%E8%AF%BE%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>CMU15445-Project0-学习心得与记录</title>
    <link href="https://galaxy-ryan.github.io/article/2024/07/18/15445-p0.html/"/>
    <id>https://galaxy-ryan.github.io/article/2024/07/18/15445-p0.html/</id>
    <published>2024-07-18T12:19:45.000Z</published>
    <updated>2024-10-07T15:54:48.630Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在开头"><a href="#写在开头" class="headerlink" title="写在开头"></a>写在开头</h2><p>很久没有更新了，在写学习记录和心得前，我在这里附上我学习CMU15445这门课程的链接，这是国外一门质量极高的数据库入门课程，以项目的形式带我们一点一点实现关系型数据库管理系统的各个基本模块，十分感谢这门课程的贡献者能够公开课程供大家学习啦：</p><p><a href="https://15445.courses.cs.cmu.edu/spring2023">CMU15445-Spring2023</a></p><p>在这里，也十分感谢其他大佬们分享的参考文章：</p><p><a href="https://zhuanlan.zhihu.com/p/637960746">CMU 15-445&#x2F;645 (Spring 2023) Database Systems 通关指北</a></p><p><a href="https://zhuanlan.zhihu.com/p/623770086">2022 CMU-15445 全总结</a></p><p><a href="https://zhuanlan.zhihu.com/p/674080359">CMU15445 Fall2023 Project 0-4 通关全记录 - 知乎</a></p><p><a href="https://zhuanlan.zhihu.com/p/366484273">CMU 15-445：知名教授历时多年打磨，数据库神级课程限时免费！ - 知乎</a></p><h2 id="项目概述"><a href="#项目概述" class="headerlink" title="项目概述"></a>项目概述</h2><p>第0个项目主要目的是让我们熟悉C++的基本语法以及C++11引入的一些新特性。在次之前需要进行一些基本环境的配置，包括Linux系统下的<code>gdb</code>调试，clang编译器以及vscode集成开发环境(当然也可以用CLion)等，比较简单基础啦，这里附上一个我环境配置的参考链接：</p><p><a href="https://zhuanlan.zhihu.com/p/592802373">CMU 15445 vscode&#x2F;clion clang12 cmake环境配置 - 知乎 (zhihu.com)</a></p><p>这个项目的要求是让我们实现一个<code>Copy-On-Wright</code>(写入时复制)的前缀树(Trie)，以及实现前缀树的并发键值存储，并引导实现<code>gdb</code>调试和一个简单的<code>SQL</code>字符串函数(实现大小写转换)。</p><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>在p0里面我们需要了解C++11引入的一些新特性，包括<code>STL</code>容器的基本使用，智能指针的使用，以及一些锁并发的概念。由于我们实现的前缀树为<code>Copy-On-Write</code>形式，即每次写入操作时都会新建一个节点，并且通过克隆子节点的形式进行复用，而读取时只需要按照当前快照读的节点进行遍历读取(并不会读取到后面写入的值)，这样也就自然的解决了并发读情况下可能造成地读取数据不一致的问题，从而实现了读写分离。</p><p><img src="1.png" alt="结构示例" loading="lazy"></p><p>以下是我写p0时学习使用到的东西：</p><ul><li><code>unique_ptr</code>：智能指针，基于排他所有权模式(两个指针不能指向同一个资源)，无法进行<strong>左值复制构造</strong>，也无法进行<strong>左值复制赋值</strong>操作(但允许临时右值赋值构造和赋值，即利用<code>std::move()</code>函数进行移动赋值构造)；它会保存指向某个对象的指针，当它本身离开作用域时会自动释放它指向的对象。</li><li><code>shared_ptr</code>：智能指针，实现多个指针变量共享的内存管理。可以记录引用特定内存对象的智能指针数量，当复制或拷贝时，<strong>引用计数</strong>加1，当智能指针析构时，<strong>引用计数</strong>减1，如果计数为零，代表已经没有指针指向这块内存，指针就会被释放。</li><li><code>map</code>：STL中的关联容器，存储键值对元素，并且<strong>根据键（key）自动排序</strong>，不允许键重复，每个键在<code>map</code>中只能出现一次，每一个元素都是一个<strong>pair</strong>结构（<code>pair&lt;t1,t2&gt;</code>）的数据。</li><li><code>lock_guard</code>：可以对<code>std::mutex</code>进行封装，实现<a href="https://segmentfault.com/a/1190000044967349">RAII</a>的效果。</li><li><code>unique_lock</code>：实现与<code>lock_guard</code>类似的效果，此外还支持手动解锁操作以及与条件变量<code>std::condition_variable</code>结合使用进行线程等待唤醒操作。</li></ul><p>下面是我实现的基本思路：</p><ul><li><code>Get(Key)</code>：这个函数实现方式非常简单，只需要根据key从根节点进行遍历，然后找到符合key的value值节点并进行返回即可。需要注意一点小细节，值节点可能需要使用<code>dynamic_cast&lt;&gt;()</code>函数进行类型转换。</li><li><code>Put(key, value)</code>：这个实现方式多样，可以采取双指针的方式进行遍历，也可以采取栈的数据结构进行遍历，我这里采取的是递归进行遍历并更新节点。除了需要考虑采取写入时赋值策略的情况外，还需要考虑到值要放在根节点中的情况(无根造根，有根放值)。</li><li><code>Delete(key)</code>：这个与更新函数相类似，同样采取写入时复制的策略，先遍历查找key对应的值节点，然后根据情况进行删除。还需要注意删除值后如果当前节点无value且子节点为空还需要删除此节点。</li><li>并发处理：这个比较简单，只需要处理好常规的加锁问题即可。读取时考虑到获得<code>trie</code>这一步是原子性的拷贝构造，所以要为<code>root</code>专门上一把互斥锁。为了防止两个线程同时更新<code>root</code>，还需要一个<code>write</code>互斥锁。</li><li><code>Task3&amp;Task4</code>：这两个任务主要是引导我们Debug以及了解一些SQL层的相关函数，比较简单。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;写在开头&quot;&gt;&lt;a href=&quot;#写在开头&quot; class=&quot;headerlink&quot; title=&quot;写在开头&quot;&gt;&lt;/a&gt;写在开头&lt;/h2&gt;&lt;p&gt;很久没有更新了，在写学习记录和心得前，我在这里附上我学习CMU15445这门课程的链接，这是国外一门质量极高的数据库入门课程</summary>
      
    
    
    
    <category term="学习" scheme="https://galaxy-ryan.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="数据库系统" scheme="https://galaxy-ryan.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="优质课程" scheme="https://galaxy-ryan.github.io/tags/%E4%BC%98%E8%B4%A8%E8%AF%BE%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>在centos7上安装kubernetes集群环境</title>
    <link href="https://galaxy-ryan.github.io/article/2024/03/20/kubernetes-env.html/"/>
    <id>https://galaxy-ryan.github.io/article/2024/03/20/kubernetes-env.html/</id>
    <published>2024-03-20T10:35:40.000Z</published>
    <updated>2024-10-07T15:15:42.642Z</updated>
    
    <content type="html"><![CDATA[<p>在这里我们选择Linux环境安装k8s环境，安装的版本为v1.23.x。</p><p>首先需要我们准备4台Linux服务器或者虚拟机，分别作为master，node1，node2，node3节点，最低要求为2核，2G，20G硬盘。以centos7为例对四台主机进行配置，首先进行网络的配置，我这里使用的是ens33网卡，使用vim编辑器(没有请用yum安装)编辑<code>/etc/sysconfig/network-scripts/ifcfg-ens33</code>文件，修改以下网络配置(设置静态ip)：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BOOTPROTO=<span class="string">&quot;static&quot;</span></span><br><span class="line">ONBOOT=<span class="string">&quot;yes&quot;</span></span><br><span class="line">IPADDR=192.168.153.142 <span class="comment">#自己配置的静态ip，每台主机的ip不能相同</span></span><br><span class="line">GATEWAY=192.168.153.2 <span class="comment">#网关设置</span></span><br><span class="line">DNS1=192.168.153.2 <span class="comment">#DNS服务器设置</span></span><br></pre></td></tr></table></figure><p>配置主机名，修改<code>/etc/hostname</code>文件，添加主机名，以第一台主机为例，注意不要留有空格：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">k8s-master</span><br></pre></td></tr></table></figure><p>修改每台主机的<code>/etc/hosts</code>文件，添加本地域名访问ip映射，例子如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4</span><br><span class="line">::1         localhost localhost.localdomain localhost6 localhost6.localdomain6</span><br><span class="line"></span><br><span class="line">192.168.153.142 k8s-master</span><br><span class="line">192.168.153.143 k8s-node1</span><br><span class="line">192.168.153.144 k8s-node2</span><br><span class="line">192.168.153.145 k8s-node3</span><br></pre></td></tr></table></figure><p>注意，如果是虚拟机克隆的4台机器，还需需保证4台机器的uuid与mac地址不同。到这里网络配置就结束咯！下面进行4台主机环境的配置。</p><p><strong>1.1.关闭防火墙和selinux</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld &amp;&amp; systemctl <span class="built_in">disable</span> firewalld &amp;&amp; iptables -F</span><br><span class="line">sed -i <span class="string">&#x27;s/enforcing/disabled/&#x27;</span> /etc/selinux/config &amp;&amp; setenforce 0</span><br></pre></td></tr></table></figure><p><strong>1.2.关闭swap分区</strong></p><ul><li>临时关闭</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swapoff -a</span><br></pre></td></tr></table></figure><ul><li>永久关闭swap</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -ri <span class="string">&#x27;s/.*swap.*/#&amp;/&#x27;</span> /etc/fstab</span><br></pre></td></tr></table></figure><p><strong>1.3.修改内核参数</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt; /etc/sysctl.d/k8s.conf &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-ip6tables = 1</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-iptables = 1</span></span><br><span class="line"><span class="string">net.ipv4.ip_forward = 1</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line">sysctl --system</span><br></pre></td></tr></table></figure><p><strong>1.4.加载ip_vs内核模块</strong></p><ul><li>如果kube-proxy 模式为ip_vs则必须加载，也可以采用iptables（可以不做内核ipvs加载设置）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">modprobe ip_vs</span><br><span class="line">modprobe ip_vs_rr</span><br><span class="line">modprobe ip_vs_wrr</span><br><span class="line">modprobe ip_vs_sh</span><br><span class="line">modprobe nf_conntrack_ipv4</span><br></pre></td></tr></table></figure><ul><li>设置下次开机自动加载</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt; /etc/modules-load.d/ip_vs.conf &lt;&lt; <span class="string">EOF </span></span><br><span class="line"><span class="string">ip_vs</span></span><br><span class="line"><span class="string">ip_vs_rr</span></span><br><span class="line"><span class="string">ip_vs_wrr</span></span><br><span class="line"><span class="string">ip_vs_sh</span></span><br><span class="line"><span class="string">nf_conntrack_ipv4</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure><h2 id="1-5-进行时间同步设置"><a href="#1-5-进行时间同步设置" class="headerlink" title="1.5.进行时间同步设置"></a><strong>1.5.进行时间同步设置</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 启动chronyd服务</span><br><span class="line">systemctl start chronyd</span><br><span class="line">systemctl enable chronyd</span><br><span class="line">date</span><br></pre></td></tr></table></figure><h2 id="1-6-配置完后重启各台机器"><a href="#1-6-配置完后重启各台机器" class="headerlink" title="1.6.配置完后重启各台机器"></a><strong>1.6.配置完后重启各台机器</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure><p>到这里开始进行kubernetes集群环境的搭建。</p><h2 id="2-1-所有节点安装docker-ce"><a href="#2-1-所有节点安装docker-ce" class="headerlink" title="2.1.所有节点安装docker-ce"></a><strong>2.1.所有节点安装docker-ce</strong></h2><p>这里参考阿里云镜像站安装</p><p><a href="https://developer.aliyun.com/mirror/docker-ce?spm=a2c6h.13651102.0.0.3e221b11Vnzr56">https://developer.aliyun.com/mirror/docker-ce?spm=a2c6h.13651102.0.0.3e221b11Vnzr56</a></p><p>此外，需要注意的是要配置docker的cgroupdriver：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // 添加这行</span><br><span class="line">  &quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-安装kube集群（4节点）"><a href="#2-2-安装kube集群（4节点）" class="headerlink" title="2.2.安装kube集群（4节点）"></a><strong>2.2.安装kube集群（4节点）</strong></h2><p>将所有节点的kubernetes镜像切换成国内源：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; /etc/yum.repos.d/kubernetes.repo &lt;&lt; EOF</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br><span class="line">repo_gpgcheck=0</span><br><span class="line">gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>所有节点安装指定版本 kubeadm，kubelet 和 kubectl（我这里选择<code>1.23.0</code>版本的）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yum install -y kubelet-1.23.0 kubeadm-1.23.0 kubectl-1.23.0</span><br><span class="line"></span><br><span class="line"># 设置kubelet开机启动</span><br><span class="line">systemctl enable kubelet</span><br></pre></td></tr></table></figure><p><em>更改kubelet的容器路径（如果需要的话，不需要可以跳过）</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/lib/systemd/system/kubelet.service.d/10-kubeadm.conf</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Environment=&quot;KUBELET_KUBECONFIG_ARGS=--bootstrap-kubeconfig=/etc/kubernetes/bootstrap-kubelet.conf --root-dir=/mnt/sdb_new/kubelet/ --kubeconfig=/etc/kubernetes/kubelet.conf&quot;</span><br></pre></td></tr></table></figure><p>使配置生效：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br><span class="line">systemctl restart kubelet</span><br></pre></td></tr></table></figure><h2 id="2-3-部署Kubernetes集群"><a href="#2-3-部署Kubernetes集群" class="headerlink" title="2.3.部署Kubernetes集群"></a><strong>2.3.部署Kubernetes集群</strong></h2><p><strong>覆盖kubernetes的镜像地址（只需要在master节点上操作初始化命令）。</strong></p><p>首先覆盖kubeadm的镜像地址，使用此命令列出集群在配置过程中需要哪些镜像：<code>kubeadm config images list</code></p><p>更改为阿里云的镜像地址：<code>kubeadm config images list  --image-repository registry.aliyuncs.com/google_containers</code></p><p>然后将镜像手动拉取下来，这样在初始化的时候回更快一些（还有一个办法就是直接在docker上把镜像pull下来，docker只要配置一下国内源即可快速的将镜像pull下来）：<code>kubeadm config images pull  --image-repository registry.aliyuncs.com/google_containers</code></p><p><strong>初始化kubernetes（只需要在master节点上操作初始化命令）</strong></p><p>初始化 Kubernetes，指定网络地址段和镜像地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">kubeadm init \</span><br><span class="line">  --apiserver-advertise-address=192.168.153.142 \</span><br><span class="line">  --image-repository registry.aliyuncs.com/google_containers \</span><br><span class="line">  --kubernetes-version v1.23.0 \</span><br><span class="line">  --service-cidr=10.96.0.0/12 \</span><br><span class="line">  --pod-network-cidr=10.244.0.0/16 \</span><br><span class="line">  --ignore-preflight-errors=all</span><br><span class="line"></span><br><span class="line"># –apiserver-advertise-address # 集群通告地址(master 机器IP，这里用的万兆网)</span><br><span class="line"># –image-repository # 由于默认拉取镜像地址k8s.gcr.io国内无法访问，这里指定阿里云镜像仓库地址</span><br><span class="line"># –kubernetes-version #K8s版本，与上面安装的一致</span><br><span class="line"># –service-cidr #集群内部虚拟网络，Pod统一访问入口，可以不用更改，直接用上面的参数</span><br><span class="line"># –pod-network-cidr #Pod网络，与下面部署的CNI网络组件yaml中保持一致，可以不用更改，直接用上面的参数</span><br></pre></td></tr></table></figure><p>执行完之后要手动执行一些参数（尤其是 <strong>加入集群的join命令</strong> 需要复制记录下载）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p $HOME/.kube</span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br></pre></td></tr></table></figure><p>然后使用vim编辑*&#x2F;root&#x2F;.bash_profile*文件，加入下面这段并保存：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 超级用户变量</span><br><span class="line">export KUBECONFIG=/etc/kubernetes/admin.conf</span><br><span class="line"># 设置别名</span><br><span class="line">alias k=kubectl</span><br><span class="line"># 设置kubectl命令补齐功能</span><br><span class="line">source &lt;(kubectl completion bash)</span><br></pre></td></tr></table></figure><p>激活*.bash_profile<em>文件：</em><code>source /root/.bash_profile</code>*</p><p>这段要<strong>记录</strong>下来（来自k8s初始化成功之后出现的<code>join</code>命令，需要先配置完Flannel才能加入子节点），后续子节点加入master节点需要执行这段命令，每个人的不同，这是一个示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubeadm join 192.168.153.142:6443 --token ochspx.15in9qkiu5z8tx2y \</span><br><span class="line">        --discovery-token-ca-cert-hash sha256:1f31202107af96a07df9fd78c3aa9bb44fd40076ac123e8ff28d6ab691a02a31</span><br></pre></td></tr></table></figure><p><strong>设定kubeletl网络（主节点部署）</strong></p><p>部署容器网络，CNI网络插件(在Master上执行，著名的有flannel、calico等，简单易用的实现是为CoreOS提供的flannel项目)，这里使用Flannel实现。</p><p>下载<code>kube-flannel.yml</code>：*<code>wget https://raw.githubusercontent.com/flannel-io/flannel/master/Documentation/kube-flannel.yml</code>*</p><p>然后修改配置文件，找到如下位置，修改 <code>Newwork</code> 与执行 <code>kubeadm init</code> 输入的网段一致：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">net-conf.json: |</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;Network&quot;: &quot;10.244.0.0/16&quot;,</span><br><span class="line">    &quot;Backend&quot;&quot;: &#123;</span><br><span class="line">      &quot;Type&quot;: &quot;vxlan&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改配置之后安装组件：*<code>kubectl apply -f kube-flannel.yml</code>*</p><p>查看<code>flannel pod</code>状态（必须要为<code>Running</code>状态，如果<code>kube-flannel</code>起不来，那么就用<code>kubectl describe pod</code>命令查看<code>pod</code>起不来的原因并解决）</p><p><strong>子节点加入集群（在子节点上操作）</strong></p><p>初始化会生成<code>join</code>命令，需要在<strong>子节点</strong>执行即可，以下<code>token</code>作为举例，以实际为主，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm join 192.168.153.142:6443 --token ochspx.15in9qkiu5z8tx2y         --discovery-token-ca-cert-hash sha256:1f31202107af96a07df9fd78c3aa9bb44fd40076ac123e8ff28d6ab691a02a31</span><br></pre></td></tr></table></figure><p>加入之后再在主节点查看集群中节点的状态，<strong>如果所有的节点<code>STATUS</code>都为<code>Ready</code>的话，那么到此，所有的子节点加入完成！</strong></p><p><em>补充：worker节点加入集群后无法使用kubectl命令，需要将主节点中的&#x2F;etc&#x2F;kubernetes&#x2F;admin.conf文件拷贝到从node节点相同目录下，将主节点的&#x2F;root&#x2F;.bash_profile复制到worker节点，然后source &#x2F;root&#x2F;.bash_profile</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在这里我们选择Linux环境安装k8s环境，安装的版本为v1.23.x。&lt;/p&gt;
&lt;p&gt;首先需要我们准备4台Linux服务器或者虚拟机，分别作为master，node1，node2，node3节点，最低要求为2核，2G，20G硬盘。以centos7为例对四台主机进行配置，首</summary>
      
    
    
    
    <category term="技术" scheme="https://galaxy-ryan.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="分布式系统" scheme="https://galaxy-ryan.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="环境搭建" scheme="https://galaxy-ryan.github.io/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
    <category term="容器编排" scheme="https://galaxy-ryan.github.io/tags/%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92/"/>
    
  </entry>
  
  <entry>
    <title>论文分享系列-1</title>
    <link href="https://galaxy-ryan.github.io/article/2024/02/10/readings-01.html/"/>
    <id>https://galaxy-ryan.github.io/article/2024/02/10/readings-01.html/</id>
    <published>2024-02-10T02:19:36.000Z</published>
    <updated>2024-10-07T16:07:40.114Z</updated>
    
    <content type="html"><![CDATA[<p>这是一篇来自清华大学的计算机网络相关的论文阅读分享，论文名为 <em>An Efffcient Design of Intelligent Network Data Plane</em>。</p><span id="more"></span><h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>智能数据平面（IDP）：通过直接在网络数据平面上部署机器学习模型，可以使用数据驱动的模型而不是预定义的协议以线速(网络转发零减少速度)进行智能流量分析。</p><p>新兴的可编程交换机为 IDP 的实现提供了关键的硬件支持。 这方面的现有技术分为两大类：(i)侧重于从数据平面提取有用的流量信息，而将基于学习的流量分析放在控制平面上。 (ii) 进一步将学习模型嵌入到数据平面中，同时未能使用对于实现高学习精度至关重要的流级特征。 在本文中， 提出 NetBeacon 来提高模型准确性和模型部署效率方面的最新水平。 特别是，NetBeacon 提出了一种多阶段顺序模型架构，通过合并可线速计算的流级特征来提高学习准确性，从而在流的不同阶段执行动态数据包分析。 此外，NetBeacon 设计了高效的模型表示机制，以解决在网络数据平面上部署基于树的模型时的表条目爆炸问题。 最后，NetBeacon 通过多个紧密耦合的设计来强化其处理并发流的可扩展性，以管理用于存储每个流状态的有状态存储。  实现了 NetBeacon 原型，并广泛评估了其在多个流量分析任务中的性能。</p><h2 id="问题提出"><a href="#问题提出" class="headerlink" title="问题提出"></a>问题提出</h2><p>人工智能（AI）在各种网络设计中越来越受欢迎，例如视频比特率自适应、拥塞控制、流量优化、路由和网络规划。 学习的模型通常部署在终端主机或网络控制平面上以执行推理，这些主机配备了灵活的通用处理器或 GPU。</p><p>然而，直接在网络数据平面上部署用于流量分析的学习模型是一个相对较少的领域。 例如，日益复杂的网络攻击通常绕过经验学习的流量过滤器，激励社区设计基于学习的恶意流量检测机制，例如。 然而，与这些方法不同的是，IDP 实现了线速流量分析，而在网络控制平面上部署学习模型的最先进技术只能以大约 10 Gbps 的速度处理流量。 此外，将控制平面放置在流量分析的关键路径上会引入额外的反应时间。 除了安全域之外，其他网络设计（例如差异化路由、ECN阈值调整和缓冲区管理）也可能受益于IDP。</p><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p>NetBeacon：一种新颖的 IDP 设计，它在模型准确性和模型部署效率方面都达到了最先进的水平。NetBeacon 在流量分析&#x2F;分类精度和硬件表消耗方面均优于现有技术。具有以下创新设计：</p><p>(i) 围绕多阶段顺序模型架构的数据平面感知学习模型设计。 由于流的不同阶段的数据包携带不同的流级别状态，因此该模型在流的不同阶段进行动态分析，从而减少基于单个推理模型做出过早分类决策所引入的错误。 同时，该模型使用精心设计的流级和每数据包特征，可在数据平面上以线速计算，以确保可部署性。</p><p>(ii) NetBeacon 提出了一种有效的模型表示机制，以解决将决策树或森林模型表示为数据平面匹配表时的条目爆炸问题。 与最先进的 Mousika 相比，NetBeacon 显着减少了表项消耗（在某些情况下高达 75%）。</p><p>(iii) 通过区分短流和长流的处理逻辑，以及在观察存储索引冲突时允许安全存储复用，进一步强化了 NetBeacon 处理并发流的可扩展性。 这可能允许 NetBeacon 处理比用于维护每个流状态的寄存器总数更多的并发流。</p><p><strong>NetBeacon架构设计：</strong></p><p><img src="1.png" alt="架构图" loading="lazy"></p><p>从架构上来说，NetBeacon 围绕两个主要组件进行设计：数据平面感知模型设计和高效模型部署。</p><p>数据平面感知模型设计是一种生成硬件友好的学习模型的协同设计方法。 为此，该特征工程依赖于在切换管道上以线速可提取或可计算的特征。 此外，考虑到流级特征（例如，数据包大小的平均值）随着流的进行而变化，NetBeacon 提出了一种多阶段顺序模型架构，可以随着流的进行而做出多个推理决策，直到系统有足够的信心做出最终决定。</p><p>模型部署的关键设计是模型表示模块。 它将学习到的模型转换为数据平面上的多个特征表和一个模型表，其中特征表将特征值编码为名为范围标记的数据结构，这些数据结构进一步映射到模型表中存储的推理结果。 NetBeacon 设计了高效的编码机制，大大减少了模型表示时的表项消耗。</p><p>此外，NetBeacon 还设计了状态存储管理模块，以实现数据平面上高效的每流状态管理。 一方面，该模块使 NetBeacon 能够使用纯粹的每数据包特征（即，不为短流维护每流状态）来处理短流，其中使用学习模型对短流进行分类。 另一方面，NetBeacon 利用硬件哈希来实现存储复用。 特别是，当新流的5元组被散列到占用的寄存器（即存储冲突）时，如果存储的流是类确定的或超时的，则新流可以占用该寄存器； 否则，NetBeacon 会回退到对新流使用无状态每数据包功能。 如果数据包属于存储的流，则更新寄存器并计算特征以进行模型推理，即查询特征表和模型表。 一旦确定了数据包的推理结果，用户就可以根据结果设计定制的后处理，例如做出丢弃或允许的二元决策，或相应地分配细粒度的不同服务优先级。</p><h2 id="数据平面感知模型设计"><a href="#数据平面感知模型设计" class="headerlink" title="数据平面感知模型设计"></a>数据平面感知模型设计</h2><p>NetBeacon 中的决策树学习模型可以使用每数据包特征和流级特征。</p><p><img src="2.png" alt="模型学习特征" loading="lazy"></p><p><strong>包级特征</strong>即包大小、生存时间值、协议。</p><p><strong>流级特征</strong>分为聚合特征和汇总特征。 聚合特征表示为<br>$$<br>F &#x3D; aggr(a, c,d)<br>$$<br>其中 a 表示 F 中考虑的属性，c 是对该属性施加的条件，d 表示一旦数据包更新 F 值的预定规则需满足 c。例如：<br>$$<br>feature F &#x3D; aggr(packet size,[96,112),+1)<br>$$<br>记录了一个流中的数据包数量，其数据包大小在[96,112)范围内。 与聚合特征不同，汇总特征的计算不能通过预先确定的更新规则轻松表示。 代表性的汇总特征是最大值&#x2F;最小值、平均值和方差，甚至涉及硬件本身不支持的乘法或除法。流级特征是通过组合同一流中其他数据包的属性来获得的，一般来说，把具有相同五元组（源 IP 地址、源端口号、目的 IP 地址、目的端口号、协议号）的数据包集合定义为一条流。</p><p><img src="3.png" alt="特征编码" loading="lazy"></p><p>数据平面感知模型将范围特征进行特定的编码，解决了上面三元条目组合爆炸问题以及交换机不支持范围匹配的问题。</p><p><img src="4.png" alt="编码方式" loading="lazy"></p><h2 id="多阶段顺序模型"><a href="#多阶段顺序模型" class="headerlink" title="多阶段顺序模型"></a>多阶段顺序模型</h2><p>NetBeacon坚持基于决策树的学习模型，采用最先进的决策树森林模型，即随机森林（RF）和XGBoost（XGB）。 同时考虑到硬件上表项的数量是有限的，通过限制森林中的树数、最大树深度、最大叶子数等来控制模型大小。</p><p><img src="5.png" alt="集成学习" loading="lazy"></p><p>设计一个多阶段模型架构，以便在流程的不同阶段应用不同的模型。 在每个阶段，NetBeacon 使用该阶段计算的特征进行训练和推理，即第 n 个数据包的流级特征是根据前 n 个数据包计算的。该模型做出推理决策的数据包称为推理点。 推理点的精确排列取决于任务。 特别是，每个推理点本质上代表了该模型处理推理点之前的 n 个数据包之后流的分析结果。 因此，可以根据任务统一或具体地放置推理点。NetBeacon 为每个推理阶段设置确定阈值。 当特定推理点的分类概率高于相应的确定阈值时，表明多阶段顺序模型有信心在不使用后续推理点的情况下预先确定流的类别。</p><p>从单个决策树的数据平面表示开始。 在决策树中，叶子节点代表分类结果，从根节点到叶子节点的路径代表该叶子节点的匹配规则，通常是多个特征范围的串联。如图 6 中的模型表（1）所示，其中键是多个特征范围的串联，值是叶节点。NetBeacon 通过引入一种名为范围标记的新颖机制解决了上述条目组合爆炸问题。决策树模型表示为多个特征表（每个特征一个）和一个模型表。 范围标记机制确保每个叶节点仅消耗模型表中的单个三元条目，无论有多少特征表条目与该叶节点相关。从范围匹配（1）到三元匹配（2），表示叶 5 的表条目数从 1 增加到 48（8 × 1 × 6）。 在 NetBeacon 中，每个叶子仅消耗模型表中的 1 个条目。 特征表由所有叶子共享，并且它们的条目通过新颖的范围编码算法（CRC）减少。</p><p>NetBeacon 不是单独表示各个树，而是合并它们的模型表示。 具体来说，给定特征 f1，每个单独的树都可以有一个特征表。 合并这些特征表与使用该范围标记算法考虑这些表中出现的所有特征值范围来创建新的特征表相同。 对于模型表，每个条目代表各个树的叶子的一种组合。 因此，模型表条目的关键是通过考虑到与该条目关联的叶子的路径上的所有节点（代表特征范围）而获得的范围标记，并且对应的值是这些叶子的聚合（例如，Sigmoid） ，可以离线计算。 例如，图 9 中的叶子 1-2 和叶子 2-1 的组合将 f1 ∈ [25,256) 和 f1 ∈ [0,35) 合并，形成 f1 ∈ [25,35)。 组合的值为Sigmoid(-0.01+0.5)。</p><h2 id="多阶段模型推理"><a href="#多阶段模型推理" class="headerlink" title="多阶段模型推理"></a>多阶段模型推理</h2><p>该多阶段顺序模型架构在不同的推理点应用不同的模型。 直观上， 用自己的特征表和模型表分别表示每个阶段的每个模型。 或者，可以合并它们的表示。 如图所示，特征表和模型表都有一个名为total_packets的额外键，用于区分不同阶段的模型。 考虑到这些模型可能使用不同的特征，如果某个特征未被特定模型使用，则将该特征的范围标记设置为*来表示任意范围标记。 一般来说，模型推理分为两个阶段：一个阶段用于并行匹配特征表，一个阶段用于匹配（聚合）模型表。</p><p><img src="6.png" alt="模型推理" loading="lazy"></p><h2 id="有状态存储"><a href="#有状态存储" class="headerlink" title="有状态存储"></a>有状态存储</h2><p>为了利用流级功能，NetBeacon 依靠有状态存储来维护每个流的状态。 涉及控制平面在接收新流时分配不冲突的存储索引。 为了实现线速流量分析，NetBeacon 依赖于数据平面上随时可用的硬件哈希来分配存储索引。 特别是，假设有 N 个有状态寄存器可用于存储流状态，NetBeacon 将流的存储索引计算为 H（5 元组）% N，其中 H 是哈希函数。 然而，基于哈希的存储索引分配存在分配冲突的问题，即两个不同的流（具有不同的五元组）可能接收相同的存储索引。 因此，有必要将真实的流 ID（例如，5 元组）与存储索引一起存储，以便 NetBeacon 意识到冲突。 一旦发生存储冲突，如果新流覆盖存储，则原始流和新流的每流状态都将变脏。 因此，NetBeacon 提出了两种设计来缓解这一问题：一种设计可减少总体冲突几率，另一种设计可实现安全存储覆盖。</p><p>区分短流和长流。 在每个数据包特征之上合并成流级特征的原因是为了提高分类准确性。 由于流量分析的主要目标是提高所有流的总体数据包分类准确性，因此为具有较少数据包的较短流维护每流状态的边际回报比为较长流维护每流状态的边际收益要低。 NetBeacon 引入了一种长短流二元分类模型，仅使用每个数据包的特征来判断数据包是否属于长流，并且长短流二元分类模型是特定于任务的。</p><p>处理存储索引冲突。 当存储索引发生冲突时，如果现有流的推理类已确定或流已完成（即，其最后一个数据包到达时间超过预定义的超时），NetBeacon 允许新流使用占用的寄存器。 否则，NetBeacon 将回退到对新流使用每数据包无状态功能。 如果流已通过多阶段顺序模型中定义的最后一个推理点，或者模型对流在中间推理点的推理结果有足够的信心，则确定流的推理类&#x2F;结果，将流的推理结果保存在流类表中，并以流的 5 元组为关键字，以匹配该流中的后续数据包。 同时，它更新流的存储以标记其推理结果已确定，表明占用的寄存器已准备好在存储索引冲突时被未来流覆盖。 在从数据平面接收到指示流的类别已确定的消息后，控制平面将新条目动态插入到流类别表中。 同时，需要定期删除流类表中的一些条目（基于 FIFO 或 LRU 原则）以防止表溢出。</p><h2 id="集成的数据平面处理逻辑"><a href="#集成的数据平面处理逻辑" class="headerlink" title="集成的数据平面处理逻辑"></a>集成的数据平面处理逻辑</h2><p><img src="7.png" alt="数据平面" loading="lazy"></p><p>当数据包 P 到达时，其流哈希 H1 通过对数据包的 5 元组进行哈希计算（算法 1 中的第 1 行）。 然后哈希值的最后 IndexSize 位被用作存储索引 Sid（算法 1 中的第 2 行）。 如果 P 是正常数据包（即，不是重新提交数据包，如下所述），则它与流类别表 TClass 匹配（算法 1 中的第 4 行）。 如果匹配，则直接将数据包的推理结果&#x2F;类别指定为匹配的类别。</p><p>否则，NetBeacon 检查状态存储中是否已为数据包 P 分配了每流状态存储。 为此，它使用 Sid 检索存储的真实流 ID（例如，5 元组）并将其与 P 的流 ID 进行比较。 如果它们相等，NetBeacon 会识别出存储在 Sid 的流的新数据包，然后相应地更新流的状态。 同时，如果 P 恰好是推理点，NetBeacon 会计算流级特征Ff，NetBeacon 根据流级特征Ff，以及从 P 中提取的Fp进行模型推理。如果分类概率大于预定义的阈值dt，流的类别就被确定。 之后，数据平面首先更新流的存储Regsure 以指示其类别已确定，然后通知控制平面将流插入流类别表中。 如果 P 不是推理点，则使用存储的推理结果（即最近的推理点得到的结果）作为自己的分类结果。 相反，如果 P 属于没有现有存储的流，则 NetBeacon 仅使用 P 的每个数据包特征来获取其分类结果。如果 P 被分类为长流数据包，NetBeacon 将检查 Sid 上的存储是否为空或已存在。 如果是，NetBeacon 使用 Sid 索引的存储来启动 P 流的每流状态。 因此，当存储的流被类确定（或超时）时，存储寄存器被延迟释放，同时新的流被散列到寄存器。 在整个流量分析过程中，NetBeacon 使用重新提交的数据包 (i) 更新现有流的新推理结果或 (ii) 启动新流的存储。 由于Resubmit的目的是触发前阶段寄存器的修改（而不是修改数据包本身），因此我们可以通过将数据包镜像到环回端口来触发修改，而不是重新提交或重新循环，这样原始数据包就不会被修改。  此外，只有触发推理结果更新的推理点数据包才会被镜像，仅占数据包的一小部分。</p><h2 id="控制平面逻辑"><a href="#控制平面逻辑" class="headerlink" title="控制平面逻辑"></a>控制平面逻辑</h2><p>在NetBeacon中，控制平面负责：（i）从一开始就在数据平面上安装特征表和模型表，（ii）在接收到来自数据的请求时更新流类表确定流级时的平面。 当然，更新流类别表的延迟不会影响流量分析，因为与流类别表不匹配的数据包将改为遍历常规模型推理管道。 因此，控制平面脱离了 NetBeacon 中数据包分类的关键路径，保证了线速流量分析。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这是一篇来自清华大学的计算机网络相关的论文阅读分享，论文名为 &lt;em&gt;An Efffcient Design of Intelligent Network Data Plane&lt;/em&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="学习" scheme="https://galaxy-ryan.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="计算机网络" scheme="https://galaxy-ryan.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="机器学习" scheme="https://galaxy-ryan.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="论文分享" scheme="https://galaxy-ryan.github.io/tags/%E8%AE%BA%E6%96%87%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>深度学习基础环境搭建（pytorch版）</title>
    <link href="https://galaxy-ryan.github.io/article/2024/02/07/deep-learning-env.html/"/>
    <id>https://galaxy-ryan.github.io/article/2024/02/07/deep-learning-env.html/</id>
    <published>2024-02-07T14:22:18.000Z</published>
    <updated>2024-10-07T14:47:13.757Z</updated>
    
    <content type="html"><![CDATA[<h2 id="anaconda安装"><a href="#anaconda安装" class="headerlink" title="anaconda安装"></a>anaconda安装</h2><p>anaconda的安装步骤比较简单，这里就直接省略了，建议采取自定义安装的形式，并且不要安装在C盘，且给安装目录文件预留50G左右的空间。</p><p>可以参考链接：<a href="http://t.csdnimg.cn/D9V0l">conda+pytorch安装配置</a></p><h3 id="给conda添加镜像源"><a href="#给conda添加镜像源" class="headerlink" title="给conda添加镜像源"></a>给conda添加镜像源</h3><p>先进入到base环境，键入命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda config <span class="literal">--set</span> show_channel_urls yes</span><br></pre></td></tr></table></figure><p>找到.condarc文件，如果没有，需要在<u>此电脑 - C盘 - 用户 - (你的账户名)</u>目录下新建该文件，再将下列配置写入：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">channels:</span><br><span class="line">  - defaults</span><br><span class="line">show_channel_urls: true</span><br><span class="line">default_channels:</span><br><span class="line">  - http://mirrors.aliyun.com/anaconda/pkgs/main</span><br><span class="line">  - http://mirrors.aliyun.com/anaconda/pkgs/<span class="built_in">r</span></span><br><span class="line">  - http://mirrors.aliyun.com/anaconda/pkgs/msys2</span><br><span class="line">custom_channels:</span><br><span class="line">  conda<span class="literal">-forge</span>: http://mirrors.aliyun.com/anaconda/cloud</span><br><span class="line">  msys2: http://mirrors.aliyun.com/anaconda/cloud</span><br><span class="line">  bioconda: http://mirrors.aliyun.com/anaconda/cloud</span><br><span class="line">  menpo: http://mirrors.aliyun.com/anaconda/cloud</span><br><span class="line">  pytorch: http://mirrors.aliyun.com/anaconda/cloud</span><br><span class="line">  simpleitk: http://mirrors.aliyun.com/anaconda/cloud</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后在Anaconda prompt 命令窗口运行 <code>conda clean -i </code>清除索引缓存，保证用的是镜像站提供的索引。然后输入y。</p><h3 id="给pip添加镜像源"><a href="#给pip添加镜像源" class="headerlink" title="给pip添加镜像源"></a>给pip添加镜像源</h3><p>在<u>此电脑 - C盘 - 用户 - 你的账户名</u>文件夹里创建一个pip文件夹<br>在pip 文件夹里创建 pip.ini 文件，并加入下面的配置：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">global</span>]</span><br><span class="line">index<span class="literal">-url</span> = https://pypi.mirrors.ustc.edu.cn/simple/</span><br><span class="line">extra<span class="literal">-index-url</span> = https://pypi.mirrors.ustc.edu.cn/simple/</span><br><span class="line">https://mirrors.aliyun.com/pypi/simple/</span><br><span class="line">https://pypi.tuna.tsinghua.edu.cn/simple/</span><br><span class="line">http://pypi.mirrors.ustc.edu.cn/simple/</span><br><span class="line">https://pypi.org/simple/</span><br><span class="line">trusted<span class="literal">-host</span> = pypi.mirrors.ustc.edu.cn</span><br><span class="line">pypi.mirrors.ustc.edu.cn</span><br><span class="line">mirrors.aliyun.com</span><br><span class="line">pypi.tuna.tsinghua.edu.cn</span><br><span class="line">pypi.mirrors.ustc.edu.cn</span><br><span class="line">pypi.org</span><br></pre></td></tr></table></figure><h2 id="CUDA安装"><a href="#CUDA安装" class="headerlink" title="CUDA安装"></a>CUDA安装</h2><p>这里需要电脑配备有NVIDIA的显卡(GPU)，如果没有，可以直接跳过，后续环境配置选择CPU版本即可。</p><p>在这里贴一个安装教程的链接：<a href="http://t.csdnimg.cn/G4dWq">CUDA安装教程</a></p><h2 id="安装深度学习框架和软件包"><a href="#安装深度学习框架和软件包" class="headerlink" title="安装深度学习框架和软件包"></a>安装深度学习框架和软件包</h2><p>首先，你需要初始化终端Shell，以便我们可以直接运行conda。在conda的基础环境初始化完成后，关闭并重新打开当前的shell。并使用命令创建一个新的环境并激活(这里就直接命名为d2l)：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda create <span class="literal">--name</span> d2l python=<span class="number">3.9</span> <span class="literal">-y</span></span><br><span class="line">conda activate d2l</span><br></pre></td></tr></table></figure><p>我们可以按如下方式安装PyTorch的CPU或GPU版本：</p><ul><li><p>查询CUDA的版本：<code>nvcc --version</code>，后续需要根据上面cuda驱动安装的版本选择对应的pytorch版本。</p></li><li><p>进入pytorch官网，安装pytorch的GPU版本，注意选择对应的CUDA的版本，如果没有则直接选择CPU，注意这里选择conda安装的方式，复制命令并在刚刚激活环境的终端执行，这是我的版本对应命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install pytorch==<span class="number">1.11</span>.<span class="number">0</span> torchvision==<span class="number">0.12</span>.<span class="number">0</span> torchaudio==<span class="number">0.11</span>.<span class="number">0</span> cudatoolkit=<span class="number">11.3</span> <span class="literal">-c</span> pytorch</span><br></pre></td></tr></table></figure></li><li><p>安装d2l软件包，以方便调取大多数使用的函数和类，同时也需要注意自己版本：<code>pip install d2l==0.17.6</code></p></li></ul><p>安装完成后，你可以在控制台键入<code>python</code>，然后在python命令行键入下面的代码验证是否安装成功：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">查询cuda安装情况</span></span><br><span class="line"><span class="string">&quot;python控制台执行：</span></span><br><span class="line"><span class="string">!nvidia-smi</span></span><br><span class="line"><span class="string">!set cuda</span></span><br><span class="line"><span class="string">!nvcc -V</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(torch.__version__) <span class="comment"># 1.11.0</span></span><br><span class="line"><span class="built_in">print</span>(torchvision.__version__) <span class="comment"># 0.12.0</span></span><br><span class="line"></span><br><span class="line">torch.cuda.is_available()  <span class="comment"># 为True 则是cuda版本</span></span><br><span class="line">torch.device(<span class="string">&#x27;cpu&#x27;</span>), torch.device(<span class="string">&#x27;cuda&#x27;</span>), torch.device(<span class="string">&#x27;cuda:1&#x27;</span>)  <span class="comment"># 、查询可用设备</span></span><br><span class="line">torch.cuda.device_count()</span><br></pre></td></tr></table></figure><p><strong>到这里基础环境就搭建好啦！</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;anaconda安装&quot;&gt;&lt;a href=&quot;#anaconda安装&quot; class=&quot;headerlink&quot; title=&quot;anaconda安装&quot;&gt;&lt;/a&gt;anaconda安装&lt;/h2&gt;&lt;p&gt;anaconda的安装步骤比较简单，这里就直接省略了，建议采取自定义安装的形</summary>
      
    
    
    
    <category term="技术" scheme="https://galaxy-ryan.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="环境搭建" scheme="https://galaxy-ryan.github.io/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
    <category term="AI" scheme="https://galaxy-ryan.github.io/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>Scala语法特性-其他</title>
    <link href="https://galaxy-ryan.github.io/article/2024/01/31/Scala-3.html/"/>
    <id>https://galaxy-ryan.github.io/article/2024/01/31/Scala-3.html/</id>
    <published>2024-01-31T05:34:27.000Z</published>
    <updated>2024-10-07T14:43:51.976Z</updated>
    
    <content type="html"><![CDATA[<h2 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h2><p><strong>基本语法：</strong></p><p>模式匹配语法中，采用 match 关键字声明，每个分支采用 case 关键字进行声明，当需要匹配时，会从第一个 case 分支开始，如果匹配成功，那么执行对应的逻辑代码，如果匹配不成功，继续执行下一个分支进行判断。如果所有 case 都不匹配，那么会执行 case _分支，类似于 Java 中 default 语句。</p><p>每个 case 中，不需要使用 break 语句，自动中断 case。match case 语句可以匹配任何类型，而不只是字面量。</p><p>&#x3D;&gt; 后面的代码块，直到下一个 case 语句之前的代码是作为一个整体执行，可以使用{}括起来，也可以不括。</p><p><strong>模式守卫：</strong></p><p>如果想要表达匹配某个范围的数据，就需要在模式匹配中增加条件守卫。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestMatchGuard</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">       <span class="function"><span class="keyword">def</span> <span class="title">abs</span></span>(x: <span class="type">Int</span>) = x <span class="keyword">match</span> &#123;</span><br><span class="line">       <span class="keyword">case</span> i: <span class="type">Int</span> <span class="keyword">if</span> i &gt;= <span class="number">0</span> =&gt; i</span><br><span class="line">       <span class="keyword">case</span> j: <span class="type">Int</span> <span class="keyword">if</span> j &lt; <span class="number">0</span> =&gt; -j</span><br><span class="line">       <span class="keyword">case</span> _ =&gt; <span class="string">&quot;type illegal&quot;</span></span><br><span class="line">       &#125;</span><br><span class="line">       println(abs(<span class="number">-5</span>))</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>匹配样例类：</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> (<span class="params">name: <span class="type">String</span>, age: <span class="type">Int</span></span>)</span></span><br></pre></td></tr></table></figure><p>样例类仍然是类，和普通类相比，只是其自动生成了伴生对象，并且伴生对象中自动提供了一些常用的方法，如 apply、unapply、toString、equals、hashCode 和 copy。<br>样例类是为模式匹配而优化的类，因为其默认提供了 unapply 方法，因此，样例类可以直接使用模式匹配，而无需自己实现 unapply 方法。(unapply方法算是apply方法的反向操作。unapply接受一个对象，然后从对象中提取值，提取的值通常是用来构造该对象的值。)<br>构造器中的每一个参数都成为 val，除非它被显式地声明为 var（不建议这样做）。</p><p><strong>偏函数中的模式匹配：</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 偏函数定义</span></span><br><span class="line"><span class="keyword">val</span> second: <span class="type">PartialFunction</span>[<span class="type">List</span>[<span class="type">Int</span>], <span class="type">Option</span>[<span class="type">Int</span>]] = &#123;</span><br><span class="line">    <span class="keyword">case</span> x :: y :: _ =&gt; <span class="type">Some</span>(y)</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 该偏函数的功能是返回输入的 List 集合的第二个元素</span></span><br><span class="line">  <span class="comment">// 偏函数就是被包在花括号中，没有match的一组case语句，偏函数是PartialFunction[A,B]的一个实例，A代表输入数值，B代表输出数值</span></span><br><span class="line">  <span class="comment">//示例如下：</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> list: <span class="type">List</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = <span class="type">List</span>((<span class="string">&quot;a&quot;</span>, <span class="number">12</span>), (<span class="string">&quot;b&quot;</span>, <span class="number">35</span>), (<span class="string">&quot;c&quot;</span>, <span class="number">27</span>), (<span class="string">&quot;a&quot;</span>, <span class="number">13</span>))</span><br><span class="line">     <span class="comment">// 1. map转换，实现key不变，value成2倍</span></span><br><span class="line">    <span class="keyword">val</span> newList = list.map(tuple =&gt; (tuple._1, tuple._2 * <span class="number">2</span>))</span><br><span class="line">     <span class="comment">// 2. 用模式匹配对元组元素赋值，实现功能</span></span><br><span class="line">    <span class="keyword">val</span> newList2 = list.map(</span><br><span class="line">      tuple =&gt; &#123;</span><br><span class="line">        tuple <span class="keyword">match</span> &#123;</span><br><span class="line">          <span class="keyword">case</span> (word, count) =&gt; (word, count * <span class="number">2</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">     <span class="comment">// 3. 省略lambda表达式的写法，进行简化</span></span><br><span class="line">    <span class="keyword">val</span> newList3 = list.map &#123;</span><br><span class="line">      <span class="keyword">case</span> (word, count) =&gt; (word, count * <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(newList3)</span><br><span class="line">     <span class="comment">// 偏函数的应用，求绝对值</span></span><br><span class="line">     <span class="comment">// 对输入数据分为不同的情形：正、负、0</span></span><br><span class="line">    <span class="keyword">val</span> positiveAbs: <span class="type">PartialFunction</span>[<span class="type">Int</span>, <span class="type">Int</span>] = &#123;</span><br><span class="line">      <span class="keyword">case</span> x <span class="keyword">if</span> x &gt; <span class="number">0</span> =&gt; x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> negativeAbs: <span class="type">PartialFunction</span>[<span class="type">Int</span>, <span class="type">Int</span>] = &#123;</span><br><span class="line">      <span class="keyword">case</span> x <span class="keyword">if</span> x &lt; <span class="number">0</span> =&gt; -x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> zeroAbs: <span class="type">PartialFunction</span>[<span class="type">Int</span>, <span class="type">Int</span>] = &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0</span> =&gt; <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">abs</span></span>(x: <span class="type">Int</span>): <span class="type">Int</span> = (positiveAbs orElse negativeAbs orElse zeroAbs) (x)</span><br><span class="line">    println(abs(<span class="number">-67</span>))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h2><p>当编译器第一次编译失败的时候，会在当前的环境中查找能让代码编译通过的方法，用于将类型进行转换，实现二次编译。隐式转换是 Scala 特有的功能，主要分为三种<strong>转换方式</strong>。</p><ul><li>隐式函数：隐式转换可以在不需改任何代码的情况下，扩展某个类的功能</li><li>隐式参数：普通方法或者函数中的参数可以通过 implicit 关键字声明为隐式参数，调用该方法时，就可以传入该参数，编译器会在相应的作用域寻找符合条件的隐式值。同一个作用域中，相同类型的隐式值只能有一个。编译器按照隐式参数的类型去寻找对应类型的隐式值，与隐式值的名称无关。隐式参数优先于默认参数。隐式参数参与的函数是一个柯里化函数，implicit关键字是应用到整个参数列表而不是单个参数的。</li><li>隐式类：其所带的构造参数有且只能有一个。必须被定义在“类”或“伴生对象”或“包对象”里，即隐式类不能是顶级的。</li></ul><p><strong>解析机制：</strong></p><ul><li>首先会在当前代码作用域下查找隐式实体（隐式方法、隐式类、隐式对象）。</li><li>如果第一条规则查找隐式实体失败，会继续在隐式参数的类型的作用域里查找。类型的作用域是指与该类型相关联的全部伴生对象以及该类型所在包的包对象。</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">     <span class="comment">// 首先会在当前代码作用域下查找隐式实体</span></span><br><span class="line">    <span class="keyword">val</span> teacher = <span class="keyword">new</span> <span class="type">Teacher</span>()</span><br><span class="line">    teacher.eat()</span><br><span class="line">    teacher.say()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">PersonTrait</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">PersonTrait</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果第一条规则查找隐式实体失败，会继续在隐式参数的类型的作用域里查找。类型的作用域是指与该类型相关联的全部伴生对象以及该类型所在包的包对象。</span></span><br><span class="line">  <span class="keyword">implicit</span> <span class="class"><span class="keyword">class</span> <span class="title">Person5</span>(<span class="params">user: <span class="type">Teacher</span></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">      println(<span class="string">&quot;say...&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">extends</span> <span class="title">PersonTrait</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">eat</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(<span class="string">&quot;eat...&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>Scala中的泛型与Java略有不同，除去默认的<strong>非变</strong>泛型格式外，还存在<strong>协变</strong>和<strong>逆变</strong>两种格式。此外，在 Scala 中泛型是有上界下界的，限定必须从哪个类继承、或者必须是哪个类的父类，具体示例如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// [T]</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Temp</span>[<span class="type">T</span>] </span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args:<span class="type">Array</span>[<span class="type">String</span>]):<span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> temp:<span class="type">Temp</span>[<span class="type">String</span>] = <span class="keyword">new</span> <span class="type">Temp</span>[<span class="type">String</span>]</span><br><span class="line">         <span class="comment">// 当泛型中的内容之间存在父子关系的时候，编译报错。</span></span><br><span class="line">        <span class="keyword">val</span> tempAny:<span class="type">Temp</span>[<span class="type">Any</span>] =temp</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// [+T]</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Temp</span>[+<span class="type">T</span>]</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args:<span class="type">Array</span>[<span class="type">String</span>]):<span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> temp:<span class="type">Temp</span>[<span class="type">String</span>] = <span class="keyword">new</span> <span class="type">Temp</span>[<span class="type">String</span>]</span><br><span class="line">         <span class="comment">// 泛型的子类和父类之间是可以进行多态关系的，父类引用可以指向子类的对象。如下的示例就是正确的。</span></span><br><span class="line">        <span class="keyword">val</span> tempAny:<span class="type">Temp</span>[<span class="type">Any</span>] = temp</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// [-T]</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Temp</span>[-<span class="type">T</span>]</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args:<span class="type">Array</span>[<span class="type">String</span>]):<span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> tempAny:<span class="type">Temp</span>[<span class="type">Any</span>] = <span class="keyword">new</span> <span class="type">Temp</span>[<span class="type">Any</span>]</span><br><span class="line">         <span class="comment">// 泛型的子类和父类之间是有关系的，泛型的子类引用可以指向泛型父类的对象，如下的示例就是正确的。</span></span><br><span class="line">        <span class="keyword">val</span> temp:<span class="type">Temp</span>[<span class="type">String</span>] = tempAny</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 上界定义语法 使用&lt;: 定义泛型，表示该泛型的参数必须要是该类型本身或者该类型的子类</span></span><br><span class="line">[<span class="type">T</span> &lt;: 类型]</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> [<span class="type">T</span>&lt;:<span class="type">Person</span>](<span class="params">a:<span class="type">T</span>,b:<span class="type">T</span></span>)</span>&#123;&#125;</span><br><span class="line"> <span class="comment">//下界定义语法 使用&gt;: 定义泛型，表示该泛型的参数必须是该类型的父类或者类型本身</span></span><br><span class="line">[<span class="type">T</span> &gt;: 类型]</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> [<span class="type">T</span> &gt;: <span class="type">Person</span>](<span class="params">a:<span class="type">T</span>,b:<span class="type">T</span></span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;模式匹配&quot;&gt;&lt;a href=&quot;#模式匹配&quot; class=&quot;headerlink&quot; title=&quot;模式匹配&quot;&gt;&lt;/a&gt;模式匹配&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;基本语法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;模式匹配语法中，采用 match 关键字声明，每个分支采用 ca</summary>
      
    
    
    
    <category term="学习" scheme="https://galaxy-ryan.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="大数据" scheme="https://galaxy-ryan.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    <category term="编程语言" scheme="https://galaxy-ryan.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Scala语法特性-面向对象</title>
    <link href="https://galaxy-ryan.github.io/article/2024/01/30/Scala-2.html/"/>
    <id>https://galaxy-ryan.github.io/article/2024/01/30/Scala-2.html/</id>
    <published>2024-01-30T06:00:19.000Z</published>
    <updated>2024-10-07T14:41:16.660Z</updated>
    
    <content type="html"><![CDATA[<h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><p><strong>特殊：在 Scala 中可以为每个包定义一个同名的包对象，定义在包对象中的成员，作为其对应包下所有 class 和 object 的共享变量，可以被直接访问。</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> <span class="class"><span class="keyword">object</span> <span class="title">com</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> shareValue=<span class="string">&quot;share&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shareMethod</span></span>()=&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如上面定义的包对象可以使用在com包下的任何位置上。</span></span><br></pre></td></tr></table></figure><h3 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h3><ul><li><p>Scala中属性和方法的默认访问权限为public，但Scala中没有public关键字。</p></li><li><p>private为私有权限，只能在本类中或当前类的伴生对象中访问。</p></li><li><p>private[this] 只能在本类中访问，伴生对象中也不能访问。</p></li><li><p>protected为受保护权限，Scala中受保护权限比Java中更严格，可以在本类、子类、子类伴生对象中访问，同包无法访问。</p></li><li><p>protected[this] 只能在本类、子类中访问（子类伴生对象中无法访问）</p></li><li><p>private[包名]增加包访问权限，包名下的其他类也可以使用。</p></li></ul><h3 id="定义类和属性"><a href="#定义类和属性" class="headerlink" title="定义类和属性"></a>定义类和属性</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义类</span></span><br><span class="line">[<span class="keyword">private</span>[包名]|<span class="keyword">protected</span>] <span class="class"><span class="keyword">class</span> <span class="title">类名</span></span>&#123;</span><br><span class="line">   类体</span><br><span class="line">   <span class="comment">// 属性是类的一个组成部分</span></span><br><span class="line">  <span class="comment">// 在属性上面增加@BeanProperty注解的话，可以自动生成getter/setter方法，为了兼容一些需要使用到getter/setter方法的场景。</span></span><br><span class="line">  [<span class="keyword">private</span>] <span class="keyword">var</span>|<span class="keyword">val</span> 属性名称 [：属性类型] = 属性值</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以把类的属性声明在类的后面。</span></span><br><span class="line"><span class="comment">// 这里的private关键字相当于把这个类的构造器私有化，这样只能通过这个类的伴生对象来创建。直接在类后面声明属性的时候修饰符val和var的作用相同。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>[private](<span class="params">val name:<span class="type">String</span>,var age:<span class="type">Int</span></span>)</span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在属性上增加@BeanProperty注解可以自动给属性生成getter/setter方法.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">  <span class="meta">@BeanProperty</span></span><br><span class="line">  <span class="keyword">var</span> name:<span class="type">String</span> = _</span><br><span class="line">  <span class="keyword">var</span> age:<span class="type">Int</span> = _</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 属性定义为私有属性，可以通过伴生对象进行调用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>[private](<span class="params">var name:<span class="type">String</span>,var age:<span class="type">Int</span></span>)</span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定义方法"><a href="#定义方法" class="headerlink" title="定义方法"></a>定义方法</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">方法名</span></span>(参数:参数类型,参数:参数类型,...):返回值 = &#123;&#125;</span><br><span class="line"><span class="comment">// 在Scala中，函数的定义和方法的定义类似。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法调用的四种方式</span></span><br><span class="line"><span class="comment">//    方式一：后缀调用法</span></span><br><span class="line"><span class="comment">//      例如: 1.+(10)</span></span><br><span class="line"><span class="comment">//    方式二：中缀调用法</span></span><br><span class="line"><span class="comment">//      例如：1 + 10</span></span><br><span class="line"><span class="comment">//    方式三：花括号调用法 方法只有一个参数，才能使用花括号调用法，通常参数的类型是函数（方法）</span></span><br><span class="line"><span class="comment">//      例如：</span></span><br><span class="line"><span class="comment">//    方式四：无括号调用法 如果方法没有参数，可以省略方法名后面的括号</span></span><br><span class="line"><span class="comment">//      例如：println</span></span><br></pre></td></tr></table></figure><h2 id="继承、封装与多态"><a href="#继承、封装与多态" class="headerlink" title="继承、封装与多态"></a>继承、封装与多态</h2><p>继承、封装与多态与Java类似，需要注意Scala权限修饰默认为public，Scala 中多态属性和方法都是动态绑定,而 Java 中只有方法为动态绑定，属性为静态绑定。</p><h2 id="单例对象（伴生对象）"><a href="#单例对象（伴生对象）" class="headerlink" title="单例对象（伴生对象）"></a>单例对象（伴生对象）</h2><p><strong>特殊：</strong>Scala语言是完全面向对象的语言，所以并没有静态的操作（即在Scala中没有静态的概念）。但是为了能够和Java语言交互（因为Java中有静态概念），就产生了一种特殊的对象来模拟类对象，该对象为单例对象(伴生对象)。若单例对象名与类名一致，则称该单例对象为这个类的伴生对象，这个类为伴生对象的伴生类。伴生类和伴生对象的名称应该完全一致。这个类的所有“静态”内容都可以放置在它的伴生对象中声明。单例对象中的属性和方法都可以通过伴生对象名（类名）直接调用访问。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伴生对象采用 object 关键字声明</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> country: <span class="type">String</span> = <span class="string">&quot;China&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 伴生对象对应的类称之为伴生类，伴生对象的名称应该和伴生类名一致。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> name: <span class="type">String</span> = <span class="string">&quot;bobo&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">       <span class="comment">// 伴生对象中的属性和方法都可以通过伴生对象名（类名）直接调用访问。</span></span><br><span class="line">       println(<span class="type">Person</span>.country)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>同时通过伴生对象的 apply 方法，可以实现不使用 new 关键字创建对象：</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">         <span class="comment">//通过伴生对象的 apply 方法，实现不使用 new 关键字创建对象。</span></span><br><span class="line">         <span class="keyword">val</span> p1 = <span class="type">Person</span>()</span><br><span class="line">         println(<span class="string">&quot;p1.name=&quot;</span> + p1.name)</span><br><span class="line">         <span class="keyword">val</span> p2 = <span class="type">Person</span>(<span class="string">&quot;bobo&quot;</span>)</span><br><span class="line">         println(<span class="string">&quot;p2.name=&quot;</span> + p2.name)</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果想让主构造器变成私有的，可以在()之前加上 private</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="title">private</span>(<span class="params">var name: <span class="type">String</span></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(): <span class="type">Person</span> = &#123;</span><br><span class="line">         println(<span class="string">&quot;apply 空参被调用&quot;</span>)</span><br><span class="line">         <span class="keyword">new</span> <span class="type">Person</span>(<span class="string">&quot;xx&quot;</span>)</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(name: <span class="type">String</span>): <span class="type">Person</span> = &#123;</span><br><span class="line">         println(<span class="string">&quot;apply 有参被调用&quot;</span>)</span><br><span class="line">         <span class="keyword">new</span> <span class="type">Person</span>(name)</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="特质"><a href="#特质" class="headerlink" title="特质"></a>特质</h2><p>Scala 语言中，采用特质 trait（特征）来代替接口的概念，也就是说，多个类具有相同的特质（特征）时，就可以将这个特质（特征）独立出来，采用关键字 trait 声明。Scala 中的 trait 中即可以有抽象属性和方法，也可以有具体的属性和方法，一个类可以混入（mixin）多个特质。类似于 Java 中的抽象类。Scala 引入 trait 特征，第一可以替代 Java 的接口，第二个也是对单继承机制的一种补充。在每一个trait中都只存在一个主构造器，并且这个主构造器是无参的。</p><p>一个类具有某种特质（特征），就意味着这个类满足了这个特质（特征）的所有要素，所以在使用时，也采用了 extends 关键字，如果有多个特质或存在父类，那么需要采用with关键字连接。类和特质之间是继承的关系。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">特质名</span> </span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">主体</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">类名</span> <span class="keyword">extends</span> <span class="title">特质</span> 1 <span class="keyword">with</span> <span class="title">特质</span> 2 <span class="keyword">with</span> <span class="title">特质</span> 3 <span class="title">…</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">类名</span> <span class="keyword">extends</span> <span class="title">父类</span> <span class="keyword">with</span> <span class="title">特质</span> 1 <span class="keyword">with</span> <span class="title">特质</span> 2 <span class="keyword">with</span> <span class="title">特质</span> 3<span class="title">…</span></span></span><br></pre></td></tr></table></figure><p>特质可以同时拥有抽象方法和具体方法，并且所有的 Java 接口都可以当做 Scala 特质使用。为了更灵活的扩展类的功能，特质还可以采取动态混入，即在创建对象使混入特质。此外，特质还采取特质叠加的方式来解决类冲突，即将混入的多个 trait 中的冲突方法叠加起来。特质叠加示例如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Ball</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">describe</span></span>(): <span class="type">String</span> = &#123;</span><br><span class="line">    <span class="string">&quot;ball&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Color</span> <span class="keyword">extends</span> <span class="title">Ball</span> </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">describe</span></span>(): <span class="type">String</span> = &#123;</span><br><span class="line">    <span class="string">&quot;blue-&quot;</span> + <span class="keyword">super</span>.describe()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Category</span> <span class="keyword">extends</span> <span class="title">Ball</span> </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">describe</span></span>(): <span class="type">String</span> = &#123;</span><br><span class="line">    <span class="string">&quot;foot-&quot;</span> + <span class="keyword">super</span>.describe()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyBall</span> <span class="keyword">extends</span> <span class="title">Category</span> <span class="keyword">with</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">describe</span></span>(): <span class="type">String</span> = &#123;</span><br><span class="line">    <span class="string">&quot;my ball is a &quot;</span> + <span class="keyword">super</span>.describe()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestTrait</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(<span class="keyword">new</span> <span class="type">MyBall</span>().describe())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line"><span class="comment">// my ball is a blue-foot-ball</span></span><br><span class="line"><span class="comment">// 当一个类混入多个特质的时候，Scala 会对所有的特质及其父特质按照一定的顺序进行排序，而此案例中的 super.describe()调用的实际上是排好序后的下一个特质中的 describe()方法。，排序规则如下：</span></span><br><span class="line">   <span class="comment">// MyBall -&gt; Color -&gt; Category -&gt; Ball</span></span><br></pre></td></tr></table></figure><p>上述示例中的 super，不是表示其父特质对象，而是表示上述叠加顺序中的下一个特质，即，MyBall 中的 super 指代 Color，Color 中的 super 指代 Category，Category 中的 super指代 Ball。 如果想要调用某个指定的混入特质中的方法，可以增加约束：super[]，例如：super[Category].describe()。 指定调用只能指定自身的父类，父类的父类不能指定。</p><h2 id="类型检查和转换"><a href="#类型检查和转换" class="headerlink" title="类型检查和转换"></a>类型检查和转换</h2><ul><li>obj.isInstanceOf[T]：判断 obj 是不是 T 类型。</li><li>obj.asInstanceOf[T]：将 obj 类型强转成 T 类型。</li><li>classOf和getClass： 获取对象的类名。</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Person</span> </span>&#123; </span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123; </span><br><span class="line">     <span class="keyword">val</span> person = <span class="keyword">new</span> <span class="type">Person</span> </span><br><span class="line">     <span class="comment">// 判断对象是否为某个类型的实例 </span></span><br><span class="line">     <span class="keyword">val</span> bool: <span class="type">Boolean</span> = person.isInstanceOf[<span class="type">Person</span>] </span><br><span class="line">     <span class="keyword">if</span> ( bool ) &#123; </span><br><span class="line">     <span class="comment">// 将对象转换为某个类型的实例 </span></span><br><span class="line">     <span class="keyword">val</span> p1: <span class="type">Person</span> = person.asInstanceOf[<span class="type">Person</span>] </span><br><span class="line">         println(p1)</span><br><span class="line">         println(p1.getClass)</span><br><span class="line">     &#125; </span><br><span class="line">     <span class="comment">// 获取类的信息 </span></span><br><span class="line">     <span class="keyword">val</span> pClass: <span class="type">Class</span>[<span class="type">Person</span>] = classOf[<span class="type">Person</span>] </span><br><span class="line">         println(pClass) </span><br><span class="line">     &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;类和对象&quot;&gt;&lt;a href=&quot;#类和对象&quot; class=&quot;headerlink&quot; title=&quot;类和对象&quot;&gt;&lt;/a&gt;类和对象&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;特殊：在 Scala 中可以为每个包定义一个同名的包对象，定义在包对象中的成员，作为其对应包下所有 clas</summary>
      
    
    
    
    <category term="学习" scheme="https://galaxy-ryan.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="大数据" scheme="https://galaxy-ryan.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    <category term="编程语言" scheme="https://galaxy-ryan.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Scala语法特性-函数式编程</title>
    <link href="https://galaxy-ryan.github.io/article/2024/01/28/Scala-1.html/"/>
    <id>https://galaxy-ryan.github.io/article/2024/01/28/Scala-1.html/</id>
    <published>2024-01-28T06:10:34.000Z</published>
    <updated>2024-10-07T14:41:48.329Z</updated>
    
    <content type="html"><![CDATA[<h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><h3 id="函数式编程特点："><a href="#函数式编程特点：" class="headerlink" title="函数式编程特点："></a>函数式编程特点：</h3><p>函数式编程是一种<strong>编程范式</strong>，属于”结构化编程”的一种，主要思想是把运算过程写成一系列的函数调用。即将函数当做数据类型，可以接受函数当做输入(参数)或输出(返回值)。</p><p><strong>函数作为参数进行传递</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args:<span class="type">Array</span>[<span class="type">String</span>]):<span class="type">Unit</span> = &#123;</span><br><span class="line">      </span><br><span class="line">       <span class="function"><span class="keyword">def</span> <span class="title">fun</span></span>(f : (<span class="type">Int</span>,<span class="type">Int</span>)=&gt;<span class="type">Int</span>,a:<span class="type">Int</span>,b:<span class="type">Int</span>) :<span class="type">Int</span> = &#123;</span><br><span class="line">         f(a,b)</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">def</span> <span class="title">add</span> </span>(a:<span class="type">Int</span>,b:<span class="type">Int</span>):<span class="type">Int</span> = &#123;</span><br><span class="line">         a + b</span><br><span class="line">       &#125;</span><br><span class="line">       fun(add,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">       fun((a,b)=&gt;a+b,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">       fun(_+_,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>函数作为函数返回值返回</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args:<span class="type">Array</span>[<span class="type">String</span>]):<span class="type">Unit</span> = &#123;</span><br><span class="line">      <span class="comment">// 在这个示例中，f6函数作为f5的返回值</span></span><br><span class="line">          <span class="function"><span class="keyword">def</span> <span class="title">f5</span></span>(): <span class="type">Int</span> =&gt; <span class="type">Int</span> = &#123;</span><br><span class="line">              <span class="function"><span class="keyword">def</span> <span class="title">f6</span></span>(a:<span class="type">Int</span>):<span class="type">Int</span> = &#123;</span><br><span class="line">                a + <span class="number">1</span></span><br><span class="line">              &#125;</span><br><span class="line">              f6</span><br><span class="line">          &#125;</span><br><span class="line">          f5()(<span class="number">2</span>)</span><br><span class="line">          <span class="comment">// 上面定义的f6函数可以按照如下步骤进行简化</span></span><br><span class="line">          <span class="function"><span class="keyword">def</span> <span class="title">f5</span></span>(): <span class="type">Int</span> =&gt; <span class="type">Int</span> = &#123;</span><br><span class="line">               a =&gt; a + <span class="number">1</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="function"><span class="keyword">def</span> <span class="title">f5</span></span>()(a:<span class="type">Int</span>) = &#123;</span><br><span class="line">              a+<span class="number">1</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="function"><span class="keyword">def</span> <span class="title">f5</span></span>()(a:<span class="type">Int</span>)= a + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数至简原则"><a href="#函数至简原则" class="headerlink" title="函数至简原则"></a>函数至简原则</h3><ul><li><p>return 可以省略，Scala 会使用函数体的最后一行代码作为返回值。</p></li><li><p>如果函数体只有一行代码，可以省略花括号。</p></li><li><p>返回值类型如果能够推断出来，那么可以省略（:和返回值类型一起省略）。</p></li><li><p>如果有 return，则不能省略返回值类型，必须指定。</p></li><li><p>如果函数明确声明 unit，那么即使函数体中使用 return 关键字也不起作用。</p></li><li><p>Scala 如果期望是无返回值类型，可以省略等号，将无返回值的函数称之为过程。</p></li><li><p>如果函数无参，但是声明了参数列表，那么调用时，小括号，可加可不加。</p></li><li><p>如果函数没有参数列表，那么小括号可以省略，调用时小括号必须省略。</p></li></ul><h3 id="函数的闭包"><a href="#函数的闭包" class="headerlink" title="函数的闭包"></a>函数的闭包</h3><p>如果一个函数，访问到了它的外部（局部）变量的值，那么这个函数和他所处的环境，称为闭包。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args:<span class="type">Array</span>[<span class="type">String</span>]):<span class="type">Unit</span> = &#123;</span><br><span class="line">         <span class="function"><span class="keyword">def</span> <span class="title">fun</span></span>(a:<span class="type">Int</span>):<span class="type">Int</span>=&gt;<span class="type">Int</span> = &#123;</span><br><span class="line">           <span class="function"><span class="keyword">def</span> <span class="title">func</span></span>(b:<span class="type">Int</span>):<span class="type">Int</span> = &#123;</span><br><span class="line">             a + b</span><br><span class="line">           &#125;</span><br><span class="line">           func</span><br><span class="line">         &#125;</span><br><span class="line">         fun(<span class="number">5</span>)(<span class="number">6</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h3><p>把一个参数列表的多个参数，变成多个参数列表。</p><p><strong>与闭包的关系：</strong>闭包可以通过简化得到。函数柯里化一定存在闭包。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args:<span class="type">Array</span>[<span class="type">String</span>]):<span class="type">Unit</span> = &#123;</span><br><span class="line">         <span class="function"><span class="keyword">def</span> <span class="title">fun</span></span>(a:<span class="type">Int</span>):<span class="type">Int</span>=&gt;<span class="type">Int</span> = b =&gt; a + b</span><br><span class="line">         <span class="comment">// 上面的函数如果要省略返回值的话可以写成柯里化形式</span></span><br><span class="line">         <span class="function"><span class="keyword">def</span> <span class="title">fun</span></span>(a:<span class="type">Int</span>)(b:<span class="type">Int</span>) = a + b</span><br><span class="line">         fun(<span class="number">5</span>)(<span class="number">6</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="控制抽象"><a href="#控制抽象" class="headerlink" title="控制抽象"></a>控制抽象</h3><p>这里记录函数的几种调用方式：</p><p><strong>值调用(call-by-value)</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把计算后的值传递过去</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args:<span class="type">Array</span>[<span class="type">String</span>]):<span class="type">Unit</span> = &#123;</span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">foo</span></span>(a:<span class="type">Int</span>):<span class="type">Unit</span> = &#123;</span><br><span class="line">       println(a)</span><br><span class="line">     &#125;</span><br><span class="line">     foo(<span class="number">4</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>名调用(call-by-name)</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把代码块传递过去(重要)</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args:<span class="type">Array</span>[<span class="type">String</span>]):<span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">foo</span></span>(a: =&gt; <span class="type">Unit</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">          a</span><br><span class="line">        &#125;</span><br><span class="line">        foo&#123;println(<span class="string">&quot;名调用&quot;</span>)&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">fun</span></span>(condition: =&gt; <span class="type">Boolean</span>): (=&gt; <span class="type">Unit</span>) =&gt; <span class="type">Unit</span> = &#123;</span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">loop</span></span>(operation: =&gt; <span class="type">Unit</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">          operation</span><br><span class="line">          fun(condition)(operation)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      loop</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用匿名函数简化</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fun2</span></span>(condition: =&gt; <span class="type">Boolean</span>): (=&gt; <span class="type">Unit</span>) =&gt; <span class="type">Unit</span> = &#123;</span><br><span class="line">      operation =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">          operation</span><br><span class="line">          fun2(condition)(operation)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//使用函数柯里化简化</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fun3</span></span>(condition: =&gt; <span class="type">Boolean</span>)(operation: =&gt; <span class="type">Unit</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">      <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">        operation</span><br><span class="line">        fun3(condition)(operation)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//类似实现while循环的效果</span></span><br><span class="line">    <span class="keyword">var</span> n = <span class="number">5</span></span><br><span class="line">    fun3(n &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">      println(n)</span><br><span class="line">      n -= <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="惰性加载"><a href="#惰性加载" class="headerlink" title="惰性加载"></a>惰性加载</h3><p>函数的惰性加载，即当函数返回值被声明为 lazy 时，函数的执行将被推迟，直到我们首次对此取值，该函数才会执行。lazy 不能修饰 var 类型的变量。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"> <span class="keyword">lazy</span> <span class="keyword">val</span> res = sum(<span class="number">10</span>, <span class="number">30</span>)</span><br><span class="line"> println(<span class="string">&quot;----------------&quot;</span>)</span><br><span class="line"> println(<span class="string">&quot;res=&quot;</span> + res)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span></span>(n1: <span class="type">Int</span>, n2: <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line"> println(<span class="string">&quot;sum 被执行...&quot;</span>)</span><br><span class="line"> <span class="keyword">return</span> n1 + n2</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果应为：</span></span><br><span class="line"><span class="comment">// ----------------</span></span><br><span class="line"><span class="comment">// sum 被执行...</span></span><br><span class="line"><span class="comment">// res=40</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;函数式编程&quot;&gt;&lt;a href=&quot;#函数式编程&quot; class=&quot;headerlink&quot; title=&quot;函数式编程&quot;&gt;&lt;/a&gt;函数式编程&lt;/h2&gt;&lt;h3 id=&quot;函数式编程特点：&quot;&gt;&lt;a href=&quot;#函数式编程特点：&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="学习" scheme="https://galaxy-ryan.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="大数据" scheme="https://galaxy-ryan.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    <category term="编程语言" scheme="https://galaxy-ryan.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://galaxy-ryan.github.io/article/2024/01/26/hello-word-hexo.html/"/>
    <id>https://galaxy-ryan.github.io/article/2024/01/26/hello-word-hexo.html/</id>
    <published>2024-01-26T04:00:00.000Z</published>
    <updated>2024-10-07T13:10:02.686Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    <category term="Other" scheme="https://galaxy-ryan.github.io/categories/Other/"/>
    
    
  </entry>
  
</feed>
