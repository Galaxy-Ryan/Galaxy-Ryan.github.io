<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>银河的白星</title>
  
  <subtitle>一个不知名的个人博客</subtitle>
  <link href="https://galaxy-ryan.github.io/atom.xml" rel="self"/>
  
  <link href="https://galaxy-ryan.github.io/"/>
  <updated>2024-10-11T05:16:10.000Z</updated>
  <id>https://galaxy-ryan.github.io/</id>
  
  <author>
    <name>Galaxy Ryan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CMU15445-Project4-学习心得与记录</title>
    <link href="https://galaxy-ryan.github.io/article/2024/10/11/15445-p4.html/"/>
    <id>https://galaxy-ryan.github.io/article/2024/10/11/15445-p4.html/</id>
    <published>2024-10-11T05:16:10.000Z</published>
    <updated>2024-10-11T05:16:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>终于来到CMU-15445课程的最后一部分，并发事务控制，这一部分的实现难度也更大，我也是通过这里的学习为后来的计算机系统能力大赛打下了良好的编程基础吧，再次感谢Andy对这门开源课程的贡献。</p><p>P4主要分为以下三个部分：</p><ul><li><strong>Lock Manager：</strong>锁管理器，利用 2PL 协议实现并发控制。支持 <code>REPEATABLE_READ</code>、<code>READ_COMMITTED</code> 和 <code>READ_UNCOMMITTED</code> 三种隔离级别，支持 <code>SHARED</code>、<code>EXCLUSIVE</code>、<code>INTENTION_SHARED</code>、<code>INTENTION_EXCLUSIVE</code> 和 <code>SHARED_INTENTION_EXCLUSIVE</code> 五种锁，支持 table 和 row 两种锁粒度，支持锁升级。这是P4最重点的部分。</li><li><strong>Deadlock Detection：</strong>死锁检测，运行在一个 background 线程，每间隔一定时间检测当前是否出现死锁，并挑选合适的事务将其 abort 以解开死锁。</li><li><strong>Concurrent Query Execution：</strong>修改之前实现的 <code>SeqScan</code>、<code>Insert</code> 和 <code>Delete</code> 算子，加上适当的锁以实现并发的查询。</li></ul><h2 id="Task1-Lock-Manager"><a href="#Task1-Lock-Manager" class="headerlink" title="Task1 Lock Manager"></a>Task1 Lock Manager</h2><p>这一个任务需要根据两阶段锁协议实现在不同隔离级别下的锁并发控制。不同隔离级别下解决的异常情况存在差异。</p><p><img src="1.png" alt="1" loading="lazy"></p><p>Lock Manager 的作用是处理事务发送的锁请求，例如有一个 SeqScan 算子需要扫描某张表，其所在事务就需要对这张表加 S 锁。而加读锁这个动作需要由 Lock Manager 来完成。需要注意的是，P4 中的实现细节很多，在我们进行相关操作后都需要同步和维护相应的状态。</p><p>首先我们来讲讲两阶段封锁协议并发控制算法：这个算法的思想是，将事务加锁和解锁分为两个阶段，分别为事务增长阶段和事务收缩阶段。我们在事务增长的阶段进行加锁，在释放一个封锁之后进入收缩阶段，而一旦事务进入收缩阶段后就不能加锁和获得任何其他封锁，只能进行事务解锁，从而保证事务的可串行化并发调度正确。由于这里只需要我们实现读未提交、读已提交以及可重复度隔离级别，因此我们不需要严格遵循两阶段封锁来进行。</p><p>我们以表级锁加锁为例，介绍 Lock Manager 的实现思路：</p><ul><li><strong>检查事务的状态：</strong>若 txn 处于 Abort&#x2F;Commit 状态，则抛逻辑异常。若 txn 处于 Shrinking 状态，则需要检查 txn 的隔离级别和当前锁请求类型，在 <code>REPEATABLE_READ</code> 下，不允许解锁，造成事务终止，并抛出 <code>LOCK_ON_SHRINKING</code> 异常；在 <code>READ_COMMITTED</code> 下，若为 IS&#x2F;S 锁，则正常通过，否则抛 <code>LOCK_ON_SHRINKING</code>异常；在 <code>READ_UNCOMMITTED</code> 下，若为 IX&#x2F;X 锁，抛 <code>LOCK_ON_SHRINKING</code>异常，否则抛 <code>LOCK_SHARED_ON_READ_UNCOMMITTED</code>异常。若 txn 处于 Growing 状态，若隔离级别为 <code>READ_UNCOMMITTED</code> 且锁类型为 S&#x2F;IS&#x2F;SIX，抛 <code>LOCK_SHARED_ON_READ_UNCOMMITTED</code>。其余状态正常通过。</li><li><strong>获取锁队列：</strong>从 <code>table_lock_map_</code> 中获取 table 对应的 lock request queue。注意需要对 map 加锁，并且为了提高并发性，在获取到 queue 之后立即释放 map 的锁。若 queue 不存在则创建。</li><li><strong>检查是否需要进行锁升级：</strong>我们需要遍历队列查看有没有与当前事务 id 相同的请求。如果存在这样的请求，并且该请求已经被授予，则代表当前事务在此前已经得到了在此资源上的一把锁，接下来可能需要锁升级。因为假如事务此前的请求还没有被通过，事务会被阻塞在 Lock Manager 中，不可能再去尝试获取另一把锁。接着判断锁升级的条件，判断此前授予锁类型是否与当前请求锁类型相同。若相同，则代表是一次重复的请求，直接返回。若不同，判断当前资源上是否有另一个事务正在尝试升级。若有，则终止当前事务，抛出 <code>UPGRADE_CONFLICT</code> 异常。因为不允许多个事务在同一资源上同时尝试锁升级。然后，判断升级锁的类型和之前锁是否兼容，不能反向升级。</li><li><strong>将锁请求加入请求队列，并尝试获取锁：</strong>这里需要用到条件变量，条件变量是线程同步中的一种机制，通常和互斥锁配合使用来完成线程同步通信。条件变量与互斥锁配合使用。首先需要持有锁，并查看是否能够获取资源。这个锁与资源绑定，是用来保护资源的锁。若暂时无法获取资源，则调用条件变量的 wait 函数，此时当前线程会被挂起，以节省资源。此外，允许有多个线程在 wait 同一个 latch。当其他线程的活动使得资源状态发生改变时，需要调用条件遍历的 <code>notify_all()</code> 函数，将阻塞在此条件变量上的所有线程进行唤醒。</li><li><strong>进行锁授予：</strong>我们需要遍历请求队列，判断当前锁请求是否与所有的已经 granted 的请求兼容，若存在不兼容的请求则不能进行锁授予。接着需要我们判断优先级，遍历队列，如果当前请求是第一个 waiting 状态的请求，则代表优先级最高。如果当前请求前面还存在其他 waiting 请求，则要判断当前请求是否和前面的 waiting 请求兼容。若兼容，则仍可以视为优先级最高。若存在不兼容的请求，则优先级不为最高。也就是所有兼容的锁请求可以被一起授予。</li></ul><p>接着我们介绍事务解锁时 Lock Manager 的实现思路，同样以表级锁解锁为例：</p><ul><li>检查表上的行级锁是否都已经进行释放。</li><li>获取对应的请求队列，遍历请求队列，找到对应的锁请求，若不存在对应的请求，抛 <code>ATTEMPTED_UNLOCK_BUT_NO_LOCK_HELD</code> 异常。找到对应的请求后，根据事务的隔离级别和锁类型修改其状态。当隔离级别为 <code>REPEATABLE_READ</code> 时，S&#x2F;X 锁释放会使事务进入 Shrinking 状态。当为 <code>READ_COMMITTED</code> 时，只有 X 锁释放使事务进入 Shrinking 状态。当为 <code>READ_UNCOMMITTED</code> 时，X 锁释放使事务 Shrinking，S 锁不会出现。</li><li>最后，在请求队列中移除对应的锁请求即可。</li></ul><h2 id="Task2-Deadlock-Detection"><a href="#Task2-Deadlock-Detection" class="headerlink" title="Task2 Deadlock Detection"></a>Task2 Deadlock Detection</h2><p>由于我们采用两阶段封锁协议，可能会遇到多个事务的循环等待而产生的死锁问题。在这一部分，我们需要使用wait for图算法来定期检查事务之间的等待关系，如果图中出现环的结构，则代表出现死锁，需要挑选事务终止以打破死锁。这里我们并不需要时刻维护 wait for 图，而是在死锁检测线程被唤醒时，根据当前请求队列构建 wait for 图，再通过 wait for 图判断是否存在死锁。当判断完成后，将丢弃当前 wait for 图。下次线程被唤醒时再重新构建。 </p><p>构建 wait for 图的过程是，遍历 <code>table_lock_map</code> 和 <code>row_lock_map</code> 中所有的请求队列，对于每一个请求队列，将所有满足等待关系的一对 tid 加入 wait for 图的边集。满足等待关系是指，对于两个事务 a 和 b，a 是 waiting 请求，b 是 granted 请求，则生成 <code>a-&gt;b</code> 一条边。</p><p>在成功构建 wait for 图后，我们通过<code>DFS</code>搜索算法进行有向图环检测。在发现环后，我们可以得到环上的所有节点。此时我们挑选最年轻的事务将其终止，释放其持有的锁，并唤醒正在阻塞的相关事务。需要注意，图中可能存在多个环，需要我们重复这个过程直到当前存在的所有环都被打破。</p><h2 id="Task3-Concurrent-Query-Execution"><a href="#Task3-Concurrent-Query-Execution" class="headerlink" title="Task3 Concurrent Query Execution"></a>Task3 Concurrent Query Execution</h2><p>这一部分需要我们将 transaction 应用到之前实现的算子（Insert、Delete与SeqScan）中，以支持事务的并发执行。</p><p><strong>SeqScan：</strong>在<code>READ_UNCOMMITTED</code>的隔离级别下则无需加锁。在 <code>READ_COMMITTED</code> 下，在 <code>Next()</code> 函数中，若表中已经没有数据，则提前释放之前持有的锁。在 <code>REPEATABLE_READ</code> 下，在 Commit&#x2F;Abort 时统一释放，无需手动释放。在进行表扫描的时候，我们需要先给表加上意向读锁，然后给相应的行加上 S 锁。当然如果是全表扫描则可以直接给表加上读锁。</p><p><strong>Insert&amp;Delete：</strong>在这里，两个算子的加锁思路类似。我们需要先给对应的表加上意向写锁，再为行加上 X 锁。锁在 Commit&#x2F;Abort 时统一释放，无需手动释放。在这里其实就可以发现，我们为 Insert 算子加行锁是解决不了幻读问题的，因为插入的是新构造的元组，而我们无法解决查询时的间隙问题。当然在P4不需要我们实现可串行化隔离级别，因此就不用考虑这个问题。</p><p>最后，终于完成CMU-15445的学习笔记记录啦，总的来说还是有很多收获的，特别是混杂着期末和各种竞赛时痛苦Debug的那段时光！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;终于来到CMU-15445课程的最后一部分，并发事务控制，这一部分的实现难度也更大，我也是通过这里的学习为后来的计算机系统能力大赛打下了良好的编程基础吧，再次感谢Andy对这门开源课程的贡献。&lt;/p&gt;
&lt;p&gt;P4主要分为以下三个部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;stron</summary>
      
    
    
    
    <category term="学习" scheme="https://galaxy-ryan.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="数据库系统" scheme="https://galaxy-ryan.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="优质课程" scheme="https://galaxy-ryan.github.io/tags/%E4%BC%98%E8%B4%A8%E8%AF%BE%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>CMU15445-Project3-学习心得与记录</title>
    <link href="https://galaxy-ryan.github.io/article/2024/10/10/15445-p3.html/"/>
    <id>https://galaxy-ryan.github.io/article/2024/10/10/15445-p3.html/</id>
    <published>2024-10-10T12:54:52.000Z</published>
    <updated>2024-10-10T12:54:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>又记一次很久没更新了，写完项目真的应该及时记录博客思路，不过现在作为一个回顾也不错。P3这一部分需要我们实现数据库的执行引擎算子，同时需要我们阅读大量的代码来理解项目内部的数据结构。</p><p>首先我们来看一下Bustub的整体架构图：</p><p><img src="1.png" alt="1" loading="lazy"></p><p>我们梳理一下从一条<code>SQL</code>语句开始到执行结束的整个过程：一条<code>SQL</code>语句，首先经过 Parser 生成一棵抽象语法树 AST。在得到 AST 后，Binder 遍历 AST，将这些词语绑定到数据库实体上。实体是 Bustub 可以理解的各种 c++ 类。绑定完成后，得到的结果是一棵 Bustub 可以直接理解的树。把它叫做 Bustub AST。得到 Bustub AST 后，Planner 遍历这棵树，生成初步的查询计划。查询计划也是一棵树的形式，查询计划规定了数据的流向。数据从树叶流向树根，自底向上地流动，在根节点输出结果。由 Planner 得到初步的查询计划后，再将查询计划交给 Optimizer 进行修改优化（可以采用预定义规则或者代价评估的方式进行），最后生成优化过后的最终查询计划。<strong>在拿到 Optimizer 生成的具体的查询计划后，就可以生成真正执行查询计划的一系列算子了，也就是我们在P3中需要实现的部分。</strong></p><p>算子的执行模型大致分为以下三种：</p><ol><li>Iterator Model&#x2F;Pipeline Model，或<a href="https://zhida.zhihu.com/search?content_id=218704765&content_type=Article&match_order=1&q=%E7%81%AB%E5%B1%B1%E6%A8%A1%E5%9E%8B&zhida_source=entity">火山模型</a>。每个算子都有 <code>Init()</code> 和 <code>Next()</code> 两个方法。<code>Init()</code> 对算子进行初始化工作。<code>Next()</code> 则是向下层算子请求下一条数据。当 <code>Next()</code> 返回 false 时，则代表下层算子已经没有剩余数据，迭代结束。这种模型的弊端在于函数开销大。</li><li>Materialization Model，所有算子立即计算出所有结果并返回。和 Iterator Model 相反。这种模型的弊端显而易见，当数据量较大时，内存占用很高。但减少了函数调用的开销。比较适合查询数据量较小的 OLTP workloads。</li><li>Vectorization Model，对上面两种模型的中和，一次调用返回一批数据。利于 SIMD 加速。目前比较先进的 OLAP 数据库都采用这种模型。</li></ol><p>这里课程采用的是第一种方式。</p><p><img src="2.png" alt="2" loading="lazy"></p><h2 id="Task1-Access-Method-Executors"><a href="#Task1-Access-Method-Executors" class="headerlink" title="Task1-Access Method Executors"></a>Task1-Access Method Executors</h2><p>Task 1 包含 5 个算子，SeqScan、Insert、Delete、Update 和 IndexScan。实现时所有要用到的系统资源，例如 Catalog，Buffer Pool 等，是由 <code>ExecutorContext</code> 提供的。</p><ul><li>SeqScan：需要读取给定 table 中的所有 tuple，仅会出现在查询计划的叶子节点处。这里我们使用已经提供的 <code>TableIterator</code>进行扫表的元组操作。</li><li>Insert：需要我们实现插入元组的操作，插入元组的顺序是没有要求的，这是数据中的三大写算子之一。Insert 一定是查询计划的根节点，且仅需返回一个代表修改行数的 tuple。同时，我们需要更新与 table 相关的所有 index。index 与 table 类似，同样由 Catalog 管理。需要注意的是，由于可以对不同的字段建立 index，一个 table 可能对应多个 index，所有的 index 都需要更新。</li><li>Delete：需要我们进行元组的删除，这里并不是直接删除，而是将 tuple 标记为删除状态，也就是逻辑删除，在事务提交后，再进行物理删除。同样也是作为数据库中的写算子，出现在查询计划的根节点。</li><li>Update：需要进行元组的更新，在这里，我们可以将更新步骤拆为两个部分，按照元组先插入再进行逻辑删除的思路进行拆分，从而完成元组的更新。Update算子同样也是作为数据库中的写算子出现。</li><li>IndexScan：这个算子需要我们实现索引扫描的操作。可以使用我们在 Project 2 中实现的 B+Tree Index Iterator，遍历 B+ 树叶子节点。由于我们实现的是非聚簇索引，在叶子节点只能获取到 RID，需要拿着 RID 去 table 查询对应的 tuple。</li></ul><h2 id="Task2-Aggregation-Join-Executors"><a href="#Task2-Aggregation-Join-Executors" class="headerlink" title="Task2 - Aggregation &amp; Join Executors"></a>Task2 - Aggregation &amp; Join Executors</h2><p>Task 2 包含了 3 个算子，Aggregation、NestedLoopJoin 和 HashJoin。</p><ul><li>Aggregation：这个算子需要我们实现聚合函数的相关计算。与其他算子有所不同，这个算子会打破 iteration model 的规则，在 Aggregation 的 <code>Init()</code> 函数中，我们就要将所有结果全部计算出来。而 <code>SimpleAggregationHashTable</code> 就是计算并保存 Aggregation 结果的数据结构。<code>SimpleAggregationHashTable</code> 维护一张 hashmap，键为 <code>AggregateKey</code>，值为 <code>AggregateValue</code>，均为 <code>std::vector&lt;Value&gt;</code>。key 代表 group by 的字段的数组，value 则是需要 aggregate 的字段的数组。在下层算子传来一个 tuple 时，将 tuple 的 group by 字段和 aggregate 字段分别提取出来，调用 <code>InsertCombine()</code> 将 group by 和 aggregate 的映射关系存入 <code>SimpleAggregationHashTable</code>。若当前 hashmap 中没有 group by 的记录，则创建初值；若已有记录，则按 aggregate 规则逐一更新所有的 aggregate 字段。</li><li>NestedLoopJoin：这个算子需要我们按照嵌套循环的思路实现连接算法。NestedLoopJoin 算法本身并不难，就是需要我们注意迭代器要保存上下文信息，防止遗漏部分需要连接匹配的元组。</li><li>HashJoin：这一部分需要我们编写一个优化规则，在满足一定条件时，将 NestedLoopJoin 优化为 HashJoin。那么在什么条件下优化为 HashJoin 呢？当然是满足等值条件时，即联接谓词是两列之间的等条件的联合时，就可以使用哈希联接算法。注意这一部分不需要我们考虑外部内存的连接算法。这里的基本思路是选择一张表（最好是小表）进行哈希处理，生成哈希表，因为需要内存中可以放得下。然后通过遍历另一表的数据，通过哈希键值查询进行匹配，满足条件则进行连接操作。</li></ul><h2 id="Task-3-Sort-Limit-Executors-and-Top-N-Optimization"><a href="#Task-3-Sort-Limit-Executors-and-Top-N-Optimization" class="headerlink" title="Task 3 Sort + Limit Executors and Top-N Optimization"></a>Task 3 Sort + Limit Executors and Top-N Optimization</h2><p>Task 3 中要实现 3 个算子，Sort、Limit 和 TopN，以及将 Limit + Sort 在 Optimizer 中优化为 TopN。</p><ul><li>Sort：排序算子，需要我们在 <code>Init()</code> 中读取所有下层算子的 tuple，并按 ORDER BY 的字段升序或降序排序。这里可以考虑采用自定义 <code>std::sort()</code>来实现。</li><li>Limit：这个算子需要我们限制输出前n个元组。和 SeqScan 的思路类似，只不过在内部维护一个 count，记录已经 emit 了多少 tuple。当下层算子空了或 count 达到规定上限后，不再返回新的 tuple。</li><li>TopN：这个算子需要我们返回最大&#x2F;最小的 n 个 tuple。需要我们添加优化规则，将 Sort + Limit 优化为 TopN。这里的思路是，对 plan tree 进行<a href="https://zhida.zhihu.com/search?content_id=218704765&content_type=Article&match_order=1&q=%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86&zhida_source=entity">后序遍历</a>，自底向上地适用规则，改写节点。遍历到 Limit 节点时，判断其下层节点是否为 Sort，若为 Sort，则将这两个节点替换为一个 TopN，进行优化。</li></ul><p>到这里，P3的主要内容就结束咯！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;又记一次很久没更新了，写完项目真的应该及时记录博客思路，不过现在作为一个回顾也不错。P3这一部分需要我们实现数据库的执行引擎算子，同时需要我们阅读大量的代码来理解项目内部的数据结构。&lt;/p&gt;
&lt;p&gt;首先我们来看一下Bustub的整体架构图：&lt;/p&gt;
&lt;p&gt;&lt;img src=</summary>
      
    
    
    
    <category term="学习" scheme="https://galaxy-ryan.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="数据库系统" scheme="https://galaxy-ryan.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="优质课程" scheme="https://galaxy-ryan.github.io/tags/%E4%BC%98%E8%B4%A8%E8%AF%BE%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>分布式系统服务治理</title>
    <link href="https://galaxy-ryan.github.io/article/2024/10/07/distribute-service.html/"/>
    <id>https://galaxy-ryan.github.io/article/2024/10/07/distribute-service.html/</id>
    <published>2024-10-07T15:00:51.000Z</published>
    <updated>2024-10-07T15:00:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>实现一个分布式系统通常会面临三大难题： <strong>故障传播性、业务拆分与聚合以及分布式事务</strong> 。这里我将总结分布式系统中的服务治理模式，目的是为了解决分布式系统故障传播性的难题。</p><h2 id="隔板模式"><a href="#隔板模式" class="headerlink" title="隔板模式"></a>隔板模式</h2><p>在分布式系统里通常将进程容器化以进行资源隔离，然后在同一个进程里的各种业务都共享线程池对外提供服务，这就经常会遇到这样的问题：</p><ol><li>业务A负载较高，抢占了线程池里的大部分线程资源，从而造成其他业务的服务质量下降；</li><li>同一个进程内新加入一个业务，这个业务会抢占其他业务的资源，从而造成系统的不稳定，比如业务性能抖动；</li><li>难以调试，比如同一个进程里的10个业务共享同一个线程池，当出现故障时难以通过简单的日志判断是哪个业务出了问题。</li></ol><p>因此，我们希望找出一个机制解决这样的问题，也就提出了隔板模式。在分布式系统里，资源隔离通常按业务分为进程级别的隔离和线程级别的隔离。进程级别隔离通常指的是容器化隔离，比如通过使用docker实现业务进程之间的资源隔离，某些简单的服务质量要求不高的业务场景下实现进程级别的隔离就够了，但是在某些对服务质量要求较高的分布式场景下需要线程级别的细粒度隔离。</p><p>线程级别隔离是指给每个跑在进程里的业务都按业务类型创建一个线程池，从而实现线程级别细粒度的资源隔离，提高业务可靠性，减少业务受其他业务影响的程度，并降低新加入的业务的给系统带来的风险。线程隔离还利于我们调试，给每一个业务都分配一个线程池名称，当业务出故障时，通过线程池名称可以很方便地定位是哪个业务出了故障，并且通过监控线程池的请求失败次数、超时次数、拒绝请求次数等可以实时的反应当前业务服务质量。当然，事物都有二元性，线程池隔离，有利自然也有弊，线程池隔离也会引入额外的一些开销。下面是<code>Hystrix</code>官网对线程池开销成本的相关统计：</p><p><img src="1.png" alt="1" loading="lazy"></p><h2 id="熔断模式"><a href="#熔断模式" class="headerlink" title="熔断模式"></a>熔断模式</h2><p>分布式系统里经常会遇到这样的场景：</p><ol><li>系统负载突然过高，比如突发的访问量、过多的请求并发数以及过多的IO等都会造成某个节点故障，比如节点A，然后节点A挂了，又把负载转给节点B，然后节点B又负载过高，接着B又挂了，就这样一连串的挂过去从单点故障造成系统级的级联故障。</li><li>当一个服务出现故障时，希望这个服务能在一个时间段内恢复，在请求被拒绝后隔一段时间再自动的去探测服务的可服务性。</li></ol><p>对应这两个场景，我们希望在分布式系统里能避免级联故障、提供快速失败快速恢复服务的能力，也就提出了熔断模式。</p><p>熔断模式也称之为断路器模式，当系统里响应时间或者异常比率或者异常数超过某个阈值时，比如超时次数或重试次数超过某个阈值就会触发熔断，接着所有的调用都快速失败，从而保证下游系统的负载安全，在断开一段时间后，熔断器又打开一点试着让部分请求负载通过，如果这些请求成功那么断路器就恢复正常工作，如果继续失败，则继续关闭服务走快速失败通道，接着继续这个过程直到重试的次数超过一定的阈值从而触发更为严重的<strong>“降级模式”</strong>，熔断模式的设计思路由下面给出：</p><p><img src="2.png" alt="2" loading="lazy"></p><h2 id="降级模式"><a href="#降级模式" class="headerlink" title="降级模式"></a>降级模式</h2><p><strong>我们来看看降级模式提出的动机：</strong></p><ol><li>某些时候系统会遇到负载过高的问题，当系统外来的或内部的负载过高超过预先定义的阈值，为了保证更重要的更紧急的业务的服务质量，希望将一些非核心的、不紧急的业务降低服务质量，从而释放一些额外的资源给紧急业务使用。</li><li>在云服务里“可用性”是一个非常重要指标，我们希望分布式系统不管出现怎么样的故障，比如服务器故障，磁盘故障，网络故障都能保持可用性，起码要保证单点故障不会造成系统故障，比如，在系统出现严重故障的时候，可以停止负载较高的写操作从而保证“读”或者“查询“服务。</li></ol><p><strong>降级的触发策略如下：</strong></p><ul><li>超时降级：在超时重试的次数达到一个阈值后就触发降级；</li><li>失败比率降级：当某个服务的失败的比率达到一定比率后就开始降级；</li><li>系统故障降级：比如网络故障，硬盘故障，电源故障，服务器故障，数据中心故障等；</li><li>限流降级：某些访问量太大的场景会触发限流，当达到限流阈值后，请求也会被降级；</li><li>重要业务救急降级：比如为了保证读或者查询的功能，降低写或者数据校验的资源配额，从而实现读服务的质量保证。</li></ul><p><strong>一般来说，降级处理可以采取以下方式：</strong></p><ul><li>资源配额调度，调度不紧急的业务支援紧急的重要的业务；</li><li>直接返回， 直接返回拒绝服务，这里请求也会丢失，这在需要保证幂等性的请求里不合适；</li><li>抛出异常，直接抛出异常，打印出出错日志，然后就不管了，请求会丢失，这在需要保证幂等性的请求里不合适；</li><li>调用回退方法，调用出现服务降级时对应的业务处理逻辑，不同场景降级处理的逻辑不同，比如可以把请求再挂到等待队列里继续重试之类，这里需要根据业务场景合理设计回退方法。</li></ul><p>一般可以把降级的等级分为几个层次：P0级，P1级，P2级，P3级，级别越高表示问题越严重， 比如：</p><ol><li>重要业务救急降级可以定义为P0级降级，只是调度次要的资源去救急，并不会出现故障；</li><li>限流降级可以定义为P1级降级，只是为了保证服务质量，而且如果不限流可能会出现系统负载过高从而出现故障；</li><li>超时降级以及失败比率降级可以定义为P2级降级，出现小范围故障，触发P2级降级，保证小故障不蔓延不传播从而造成大范围的故障；</li><li>系统故障降级可以定义为P3级降级，系统出现大范围故障，从而触发P3级降级，比如，此时可以只保证最低资源的的读请求服务，写和其他业务全部被禁止。</li></ol><h2 id="限流模式"><a href="#限流模式" class="headerlink" title="限流模式"></a>限流模式</h2><p>在分布式系统里，每个系统都有自己的容量限制，它所能处理的业务请求能力是有限的，如果不控制这些输入的请求数，突发输入过多的请求量会造成过度的资源竞争从而引发系统故障降低系统的可靠性，因此我们提出了限流模式。限流有利于控制系统资源的消耗速率有利于过载保护，有利于保护业务资源不被耗尽。</p><p>限流其原理是监控输入的请求量，当达到指定的阈值时对量进行控制，以避免系统被瞬时的请求量高峰冲垮，从而保障系统的高可用、高可靠。在分布式系统里，限流处理通常有以下几种策略：</p><ul><li>直接拒绝：当请求量超过阈值后，新的请求就会被直接拒绝，方式为直接返回或者抛出异常。这种方式比较适合于对分布式系统的负载容量已知的情况下，比如通过全链路压测已经确定了准确的系统处理能力及系统容量，对应固定窗口、滑动窗口算法。</li><li>冷启动：当分布式系统长期处于低负载的情况下，请求量突发时，会把系统负载很快拉到很高的水准，这样就可能瞬间就把系统击垮。通过”冷启动”方式，让输入的请求量缓慢增加，在一个时间段内慢慢增加到系统所能承载的阈值上限，给冷系统一个预热的时间，避免系统被压垮，对应令牌桶算法。</li><li>匀速排队：匀速排队的方式也就是控制请求以均匀的速率通过，对应的是漏桶算法。</li></ul><p>限流通常可以按空间维度划分为纵向限流以及横向限流，常用的纵向限流算法有：固定窗口、滑动窗口、令牌桶算法以及漏桶算法。常用的横向限流算法有计数算法以及时间标签算法。</p><p><img src="3.png" alt="3" loading="lazy"></p><h2 id="容错模式"><a href="#容错模式" class="headerlink" title="容错模式"></a>容错模式</h2><p>在分布式系统里，系统里出现故障时需要进行出错处理，当执行熔断或降级处理策略时，通常也需要有相应的重试处理策略，为了保证高可用以及高可靠性，也需要相应的超时处理策略，而这些策略又需要根据不同的业务场景进行设计。</p><p><img src="4.png" alt="4" loading="lazy"></p><p>以<code>Dubbo</code>框架为例，容错模式常采取以下几种策略：</p><p><strong>Failover 失败切换</strong></p><p>在分布式系统里，为了保证高可用性以及高可靠性，通常会对服务或者设备进行冗余，当一个服务或者设备出现故障时，就直接切换到另外一个服务或设备上，这种设计模式叫做故障切换。</p><p>如上图所示，服务10本来是路由到服务20的，当服务20出现故障时，从服务10路由到服务20的请求，服务20并没办法处理，这时候服务10收到一个请求超时的返回，发现服务20没法处理这个请求，为了保证高可用性，服务10的请求就被路由到服务21，从而保证了服务的高可用与可靠性，这个过程用户是不感知的。</p><p><strong>Failfast 快速失败</strong></p><p>快速失败是指当发现服务请求调用失败时，就立即上报故障，快速失败的一个重要目的是用于检测错误以便降低出错成本为系统提供足够的信息来保证高可用与高可靠，这个过程用户是感知的。</p><p>比如上图中服务20出现故障就快速上报故障给服务10，然后服务10就可以采用<code>Failover</code>策略将服务请求切换到服务21，从而避免更多的不可用时间。</p><p><strong>Failback 失败恢复</strong></p><p><code>Failback</code>跟<code>Failover</code>有点类似，但是<code>Failover</code>是发现故障时就把请求切换到别的服务或设备上去，而<code>Failback</code>是在发现下游的故障后，把请求扔到一个临时的设备或者服务或者组件（比如队列）上，然后待下游故障修复后，重新同步数据以及请求，把这些数据或者请求还原到原来的服务或者设备上。比如上图所示，在服务20出现故障后，服务10发过来的请求被放到一个临时的队列里，然后在服务20在一定的时间内被恢复后，又把这些请求从队列中恢复发到服务20，这个过程用户时不感知的。</p><p><strong>Failsafe 静默处理</strong></p><p><code>FailSafe</code>是指系统出现故障时可以直接忽略这个故障，不进行相应的故障处理，在<code>Failsafe</code>的场景下，故障不会给系统带来伤害，对服务质量也不会有什么影响，简单的处理方式就是把故障的信息写到日志里保存。</p><p><strong>Forking 请求分叉</strong></p><p>在<code>Forking</code>策略下，将请求进行裂变下发，只要一个请求处理成功整体请求就成功。比如上图所示，一个读请求到网关后被分裂成同样的请求三份，然后这三个请求被下发到服务10，11，12，只要有一个请求处理成功就返回成功。</p><h2 id="自适应模式"><a href="#自适应模式" class="headerlink" title="自适应模式"></a>自适应模式</h2><p>自适应性技术是指分布式系统能够在运行过程中根据环境变化和系统状态做出相应的调整和改变,以保持高性能和可靠性。对于自适应模式，我们希望在分布式系统里体现有限资源下的平衡，在系统健康的前提下，极致的使运用系统负载的能力，同时又保证不会主动造成系统故障，如果发现系统内部出现故障，又会自动调整下发的负载压力，这就是系统自适应保护。</p><p>下图表示了一个自适应算法，造成系统负载过高以及故障传播的因素很多，比如不合适的线程数、<code>TPS</code>或<code>QPS</code>过大、返回时间过长都有可能，通过合适的算法可以自动调整下发的压力从而保持系统的内部资源平衡。</p><p><img src="5.png" alt="5" loading="lazy"></p><p>通过采用系统自适应算法在系统的入口处，实时采集<code>QPS</code>&#x2F;<code>TPS</code>以及<code>RT</code>， 然后跟最佳样本值进行比较，依据调节系数进行计算，再调节发送的请求量，发送请求后又采集造成的影响，再反馈在系统入口处。其中，样本值可以在系统启动时按动态采样的方式计算，逐渐增加<code>QPS</code> ，当发现时延发生转折时，我们就确定这个转折点为分布式系统自适应最佳平衡点，记下该值作为当前样本。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;实现一个分布式系统通常会面临三大难题： &lt;strong&gt;故障传播性、业务拆分与聚合以及分布式事务&lt;/strong&gt; 。这里我将总结分布式系统中的服务治理模式，目的是为了解决分布式系统故障传播性的难题。&lt;/p&gt;
&lt;h2 id=&quot;隔板模式&quot;&gt;&lt;a href=&quot;#隔板模式&quot; cl</summary>
      
    
    
    
    <category term="技术" scheme="https://galaxy-ryan.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="分布式系统" scheme="https://galaxy-ryan.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>CMU15445-Project2-学习心得与记录</title>
    <link href="https://galaxy-ryan.github.io/article/2024/07/24/15445-p2.html/"/>
    <id>https://galaxy-ryan.github.io/article/2024/07/24/15445-p2.html/</id>
    <published>2024-07-24T15:00:01.000Z</published>
    <updated>2024-07-24T15:00:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>这一部分主要是参考<a href="https://zhuanlan.zhihu.com/p/580014163">十一大佬</a>的博客进行学习的，需要我们实现 B+ 树索引，主要包括单线程 B+ 树以及多线程下的并发 B+ 树的查询、插入和删除等接口。</p><p><img src="1.png" alt="1" loading="lazy"></p><h2 id="Task1-B-Tree-Pages"><a href="#Task1-B-Tree-Pages" class="headerlink" title="Task1 B+Tree Pages"></a>Task1 B+Tree Pages</h2><p>这个任务主要是让我们了解B+树的<code>Page</code>结构，分为<code>Internal Page</code>和<code>Leaf Page</code>两类。<code>b_plus_tree_page</code>是另外两个<code>page</code>的父类，即 B+ 树中 <strong>tree page</strong> 的抽象。</p><p>首先介绍<code>Internal Page</code>，<code>Internal Page</code>对应 B+ 树中的内部节点，<code>internal page</code>中，<strong>KV</strong> 对的 <em>K</em> 是能够比较大小的索引，<em>V</em> 是 page id，用来指向下一层的节点。在<code>internal page</code>中，n 个 key 可以将数轴划分为 n+1 个区域，也就对应着 n+1 个 value。通过比较 key 的大小选中下一层的节点。</p><p>然后是<code>leaf page</code>，<code>leaf page</code>和<code>internal page</code>的内存布局基本一样，只是 <code>leaf page</code>多了一个成员变量 <code>next_page_id</code>，指向下一个 <code>leaf page</code>（用于 <code>range scan</code>范围扫描）。<code>leaf page</code>的 <strong>KV</strong> 对中，<em>K</em> 是实际的索引，<em>V</em> 是 record id。record id 用于识别表中的某一条数据。<code>leaf page</code>的 <strong>KV</strong> 对是一一对应的，不像<code>internal page</code>的 value 多一个。</p><h2 id="Task2-B-Tree-Data-Structure"><a href="#Task2-B-Tree-Data-Structure" class="headerlink" title="Task2 B+Tree Data Structure"></a>Task2 B+Tree Data Structure</h2><p>这个任务是单线程 B+ 树的重点，需要实现 B+ 树的插入，删除，查找节点操作。</p><p>首先从 <strong>Search</strong> 操作开始，B+ 树的节点分为<code>internal page</code>和<code>leaf page</code>，每个 page 上的 key 有序排列。当拿到一个 key 需要查找对应的 value 时，首先需要经由<code>internal page</code>递归地向下查找，最终找到 key 所在的<code>leaf page</code>，由于 key 是有序的，可以直接进行二分搜索查找。</p><p>对于 <strong>Insert</strong> 操作，我们需要先根据 key 找到需要插入的<code>leaf page</code>，得到<code>leaf page</code>后，将 key 插入<code>leaf page</code>。要注意的是，插入时仍需保证 key 的有序性。同样可以二分搜索找到合适的位置插入。在插入后，需要检查当前 leaf page size 是否等于 max size。若相等，则要进行一次<code>leaf page</code>分裂操作，具体如下：</p><ol><li>新建一个空的 page，</li><li>将原 page 的一半转移到新 page 中，</li><li>更新原 page 和新 page 的 next page id，</li><li>获取 parent page，这里也可能产生分裂，我们需要在插入前检查 parent page size 是否等于 max size，若小于，直接返回 parent page，否则，分裂当前 internal page。并根据此后需要插入的 key 选择分裂后的两个 page 之一作为 parent page 返回。</li><li>将用于区分原 page 和新 page 的 key 插入 parent page 中，</li><li>更新 parent page 所有 child page 的父节点指针。</li></ol><p>另外需要注意一个细节，在<code>leaf page</code>分裂时，向父节点插入 key 时是复制后插入，而<code>internal page</code>分裂时，向父节点插入 key 是删除后插入。</p><p>最后是 <strong>Delete</strong> 操作，同样地，先找到<code>leaf page</code>。删除<code>leaf page</code>中 key 对应的 <strong>KV</strong> 对后，检查 size 是否小于 min size。如果小于的话，首先尝试从两侧的兄弟节点中偷一个 <strong>KV</strong> 对。注意只能从兄弟节点，即父节点相同的节点中选取。假如存在一侧节点有富余的 <strong>KV</strong> 对，则成功偷取，结束操作。若两侧都没有富余的 <strong>KV</strong> 对，则选择一侧节点与其合并。</p><p>偷取的过程比较简单，从左侧节点偷取时，把左侧节点最后一个 <strong>KV</strong> 对转移至当前节点第一个 <strong>KV</strong> 对，从右侧节点偷取时，把右侧节点的 <strong>KV</strong> 对转移至当前节点最后一个 <strong>KV</strong> 对。<code>leaf page</code>和<code>internal page</code>的偷取过程基本相同，仅需注意 <code>internal page</code>偷取后更新子节点的父节点指针。</p><p>稍难的是合并的过程。同样，任选左右侧一兄弟节点进行合并。将一个节点的所有 <strong>KV</strong> 对转移至另一节点。若合并的是<code>leaf page</code>，记得更新<code>next page id</code>。若合并的是<code>internal page</code>，记得更新合并后 page 的子节点的父节点指针。然后，删除 parent 节点中对应的 key。删除后，再次检查 size 是否小于 min size，形成向上递归。当合并<code>leaf page</code>后，简单删除父节点中对应的 key即可。而合并<code>internal page</code>后，并不是简单地删除父节点中对应 key，而是有一个父节点 key 下推的过程。</p><h2 id="Task3-An-Iterator-for-Leaf-Scans"><a href="#Task3-An-Iterator-for-Leaf-Scans" class="headerlink" title="Task3 An Iterator for Leaf Scans"></a>Task3 An Iterator for Leaf Scans</h2><p>这一部分是实现一个遍历<code>leaf page</code>的<a href="https://zhida.zhihu.com/search?q=%E8%BF%AD%E4%BB%A3%E5%99%A8&zhida_source=entity&is_preview=1">迭代器</a>。在迭代器中存储当前<code>leaf page</code>的指针和当前停留的位置即可。遍历完当前 page 后，通过 next page id 找到下一个<code>leaf page</code>。同样，需要 unpin 已经遍历完的 page。</p><h2 id="Task4-Concurrent-Index"><a href="#Task4-Concurrent-Index" class="headerlink" title="Task4 Concurrent Index"></a>Task4 Concurrent Index</h2><p>在这一部分我们需要修改 B+ 树的实现，以支持 B+ 树的并发访问操作，在这里我们就可以用到先前实现的读写页面保护接口来进行页面读写。在实现多线程版本时，可以采用一种特殊的加锁方式<code>latch crabbing</code>，基本思想是： 1. 先锁住 parent page， 2. 再锁住 child page， 3. 假设 child page 是<em>安全</em>的，则释放 parent page 的锁。此外还需要注意：</p><ul><li><code>GetValue</code>：使用读锁，获取子节点的读锁后释放父节点的读锁；</li><li><code>Insert/Remove</code>：如果确认节点不会分裂&#x2F;合并&#x2F;重分配，就将 Context 中存储的父节点都进行释放；</li><li><code>InsertIntoParent/DeleteEntry</code>：因为用到了 Page Guard，而<code>InsertIntoParent</code>又存在<a href="https://zhida.zhihu.com/search?q=%E9%80%92%E5%BD%92&zhida_source=entity&is_preview=1">递归</a>的情况，所以可能会出现 Page Guard 的生命周期在函数递归的全过程中，从而直到完成递归才释放 Page，因此需要在进入下一级递归时，及时释放当前持有的不需要的 Page Guard。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这一部分主要是参考&lt;a href=&quot;https://zhuanlan.zhihu.com/p/580014163&quot;&gt;十一大佬&lt;/a&gt;的博客进行学习的，需要我们实现 B+ 树索引，主要包括单线程 B+ 树以及多线程下的并发 B+ 树的查询、插入和删除等接口。&lt;/p&gt;
&lt;p&gt;&lt;</summary>
      
    
    
    
    <category term="学习" scheme="https://galaxy-ryan.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="数据库系统" scheme="https://galaxy-ryan.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="优质课程" scheme="https://galaxy-ryan.github.io/tags/%E4%BC%98%E8%B4%A8%E8%AF%BE%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>CMU15445-Project1-学习心得与记录</title>
    <link href="https://galaxy-ryan.github.io/article/2024/07/20/15445-p1.html/"/>
    <id>https://galaxy-ryan.github.io/article/2024/07/20/15445-p1.html/</id>
    <published>2024-07-20T13:29:45.000Z</published>
    <updated>2024-07-20T13:29:45.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="项目概述"><a href="#项目概述" class="headerlink" title="项目概述"></a>项目概述</h2><p>项目1主要实现<code>Bustub</code>数据库管理系统的存储管理部分(<code>Storage Manager</code>)，我们需要完成存储管理器中缓冲池的管理(<code>BufferPool Manager</code>)、缓冲池中页面的替换算法<code>LRU-K</code>以及处理页面的并发访问控制(<code>Page Guard</code>)。这部分逻辑和内存的管理独立于传统意义上的<code>OS Caching Mechanism</code>，是为了数据库能有比 <em>OS</em> 更加全面的内存管理机制而实现的底层数据结构。因此磁盘上page的读写是交给数据库内核而不是操作系统来做的。</p><h2 id="Task1-LRU-K-页面替换策略"><a href="#Task1-LRU-K-页面替换策略" class="headerlink" title="Task1 LRU-K 页面替换策略"></a>Task1 LRU-K 页面替换策略</h2><p>实现数据库缓冲池的页面换入换出，这里采用的是<code>LRU-K</code>算法，缓冲池里面有多个<code>frame</code>，<code>frame</code>里面存放的就是<code>page</code>，每个<code>frame</code>都维护了一个长度小于等于k的时间戳。</p><p><code>LRU-K</code>算法使用一个参数k，表示要考虑的最近访问记录的数量。它记录每个缓存项最近被访问的k次时间戳，并使用这些时间戳来评估缓存项的重要性。<code>LRU-K</code> 算法移出其向后 k 距离为替换程序中所有帧的最大值的帧。向后 k 距离的计算方法是当前时间戳与第 k 次访问的时间戳之间的时间差。</p><p>具体来说分为下面三个步骤：</p><ol><li><p><strong>访问记录</strong>：每当一个缓存项被访问时，算法会记录下该项的访问时间戳，并更新该项的访问历史。</p></li><li><p><strong>缓存命中与未命中</strong>：</p></li></ol><ul><li><strong>命中</strong>：如果访问的缓存项已经在缓存中，直接返回该项。</li><li><strong>未命中</strong>：如果缓存项不在缓存中，则需要选择一个项进行替换。</li></ul><ol start="3"><li><strong>替换决策</strong>：</li></ol><ul><li>在进行替换时，算法会比较每个缓存项的K次访问时间戳。</li><li>替换策略是选择那些K次访问时间戳最远的缓存项，即最近没有被访问的项。</li></ul><h2 id="Task2-缓冲池管理器"><a href="#Task2-缓冲池管理器" class="headerlink" title="Task2 缓冲池管理器"></a>Task2 缓冲池管理器</h2><p>现在开始实现缓冲池管理器，缓冲池是一个内存区域，用于缓存磁盘上的数据页（数据块）。主要思想是，当数据库需要访问某个数据页时，首先检查该页是否在缓冲池中，即是否访存命中，如果不在，则需要从磁盘读取。</p><p><img src="1.png" alt="1" loading="lazy"></p><p>具体来说<code>BufferpoolManager</code> 维护着数据页（Page）以及帧替换器（Replacer）的数据结构，并通过<code>page_table</code>存放着空闲的<code>frame</code>号以及<code>frameid</code>与<code>pageid</code>的映射关系。以下是各个函数的基本实现思路：</p><ul><li><code>FetchPage(page_id_t page_id)</code>：函数的作用是根据页面ID来获取页面，我们需要处理页面命中和未命中两种情况，首先检查页面是否存在于页表中，如果存在，我们就增加页面的引用计数，并记录帧的访问时间戳。如果不存在，则需要我们检查空闲帧以及替换页。</li><li><code>UnpinPage(page_id_t page_id, bool is_dirty)</code>：函数的作用是取消对页面的固定，允许其被替换。注意要考虑页面ID是否有效以及页面引用计数是否为零等情况。</li><li><code>FlushPage(page_id_t page_id)</code>：函数的作用是将指定页面的内容刷新写回磁盘，比较简单。</li><li><code>NewPage(page_id_t* page_id)</code>：函数的作用是创建一个新页面，并返回该页面的指针和ID。如果没有空闲帧，则尝试通过替换策略获取一个帧。注意如果替换的页为脏页，我们则需要对页面进行刷脏，写回磁盘。</li><li><code>DeletePage(page_id_t page_id)</code>：函数的作用是删除指定页面，我们需要检查页面ID是否在<code>page_table</code>中以及是否被固定，并且需要考虑刷脏、更新页表和空闲帧列表的情况。</li><li><code>FlushAllPages()</code>：函数的作用是刷新所有缓冲池中的页面，确保所有脏页都写回磁盘即可。</li></ul><p>在这里我们为了保证函数逻辑的正确性，可以先将每个函数加上函数作用域的全局锁，后面再进行并发部分的优化。</p><h2 id="Task3-读写页面保护"><a href="#Task3-读写页面保护" class="headerlink" title="Task3 读写页面保护"></a>Task3 读写页面保护</h2><p>这一部分主要是为了解决后续项目开发中页面使用后忘记<code>UnpinPage</code>带来的问题。<code>Page Guard </code>确保在相应对象超出范围时自动解锁页面，同时也简化了P2里B+树的并发实现。作为一个懒人，自己写博客的时间与完成项目的时间有一段距离了，并且这一部分实现不算太难，就不记录思路咯！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;项目概述&quot;&gt;&lt;a href=&quot;#项目概述&quot; class=&quot;headerlink&quot; title=&quot;项目概述&quot;&gt;&lt;/a&gt;项目概述&lt;/h2&gt;&lt;p&gt;项目1主要实现&lt;code&gt;Bustub&lt;/code&gt;数据库管理系统的存储管理部分(&lt;code&gt;Storage Manager</summary>
      
    
    
    
    <category term="学习" scheme="https://galaxy-ryan.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="数据库系统" scheme="https://galaxy-ryan.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="优质课程" scheme="https://galaxy-ryan.github.io/tags/%E4%BC%98%E8%B4%A8%E8%AF%BE%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>CMU15445-Project0-学习心得与记录</title>
    <link href="https://galaxy-ryan.github.io/article/2024/07/16/15445-p0.html/"/>
    <id>https://galaxy-ryan.github.io/article/2024/07/16/15445-p0.html/</id>
    <published>2024-07-16T12:19:45.000Z</published>
    <updated>2024-07-16T12:19:45.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在开头"><a href="#写在开头" class="headerlink" title="写在开头"></a>写在开头</h2><p>很久没有更新了，在写学习记录和心得前，我在这里附上我学习CMU15445这门课程的链接，这是国外一门质量极高的数据库入门课程，以项目的形式带我们一点一点实现关系型数据库管理系统的各个基本模块，十分感谢这门课程的贡献者能够公开课程供大家学习啦：</p><p><a href="https://15445.courses.cs.cmu.edu/spring2023">CMU15445-Spring2023</a></p><p>在这里，也十分感谢其他大佬们分享的参考文章：</p><p><a href="https://zhuanlan.zhihu.com/p/637960746">CMU 15-445&#x2F;645 (Spring 2023) Database Systems 通关指北</a></p><p><a href="https://zhuanlan.zhihu.com/p/623770086">2022 CMU-15445 全总结</a></p><p><a href="https://zhuanlan.zhihu.com/p/674080359">CMU15445 Fall2023 Project 0-4 通关全记录 - 知乎</a></p><p><a href="https://zhuanlan.zhihu.com/p/366484273">CMU 15-445：知名教授历时多年打磨，数据库神级课程限时免费！ - 知乎</a></p><h2 id="项目概述"><a href="#项目概述" class="headerlink" title="项目概述"></a>项目概述</h2><p>第0个项目主要目的是让我们熟悉C++的基本语法以及C++11引入的一些新特性。在次之前需要进行一些基本环境的配置，包括Linux系统下的<code>gdb</code>调试，clang编译器以及vscode集成开发环境(当然也可以用CLion)等，比较简单基础啦，这里附上一个我环境配置的参考链接：</p><p><a href="https://zhuanlan.zhihu.com/p/592802373">CMU 15445 vscode&#x2F;clion clang12 cmake环境配置 - 知乎 (zhihu.com)</a></p><p>这个项目的要求是让我们实现一个<code>Copy-On-Wright</code>(写入时复制)的前缀树(Trie)，以及实现前缀树的并发键值存储，并引导实现<code>gdb</code>调试和一个简单的<code>SQL</code>字符串函数(实现大小写转换)。</p><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>在p0里面我们需要了解C++11引入的一些新特性，包括<code>STL</code>容器的基本使用，智能指针的使用，以及一些锁并发的概念。由于我们实现的前缀树为<code>Copy-On-Write</code>形式，即每次写入操作时都会新建一个节点，并且通过克隆子节点的形式进行复用，而读取时只需要按照当前快照读的节点进行遍历读取(并不会读取到后面写入的值)，这样也就自然的解决了并发读情况下可能造成地读取数据不一致的问题，从而实现了读写分离。</p><p><img src="1.png" alt="结构示例" loading="lazy"></p><p>以下是我写p0时学习使用到的东西：</p><ul><li><code>unique_ptr</code>：智能指针，基于排他所有权模式(两个指针不能指向同一个资源)，无法进行<strong>左值复制构造</strong>，也无法进行<strong>左值复制赋值</strong>操作(但允许临时右值赋值构造和赋值，即利用<code>std::move()</code>函数进行移动赋值构造)；它会保存指向某个对象的指针，当它本身离开作用域时会自动释放它指向的对象。</li><li><code>shared_ptr</code>：智能指针，实现多个指针变量共享的内存管理。可以记录引用特定内存对象的智能指针数量，当复制或拷贝时，<strong>引用计数</strong>加1，当智能指针析构时，<strong>引用计数</strong>减1，如果计数为零，代表已经没有指针指向这块内存，指针就会被释放。</li><li><code>map</code>：STL中的关联容器，存储键值对元素，并且<strong>根据键（key）自动排序</strong>，不允许键重复，每个键在<code>map</code>中只能出现一次，每一个元素都是一个<strong>pair</strong>结构（<code>pair&lt;t1,t2&gt;</code>）的数据。</li><li><code>lock_guard</code>：可以对<code>std::mutex</code>进行封装，实现<a href="https://segmentfault.com/a/1190000044967349">RAII</a>的效果。</li><li><code>unique_lock</code>：实现与<code>lock_guard</code>类似的效果，此外还支持手动解锁操作以及与条件变量<code>std::condition_variable</code>结合使用进行线程等待唤醒操作。</li></ul><p>下面是我实现的基本思路：</p><ul><li><code>Get(Key)</code>：这个函数实现方式非常简单，只需要根据key从根节点进行遍历，然后找到符合key的value值节点并进行返回即可。需要注意一点小细节，值节点可能需要使用<code>dynamic_cast&lt;&gt;()</code>函数进行类型转换。</li><li><code>Put(key, value)</code>：这个实现方式多样，可以采取双指针的方式进行遍历，也可以采取栈的数据结构进行遍历，我这里采取的是递归进行遍历并更新节点。除了需要考虑采取写入时赋值策略的情况外，还需要考虑到值要放在根节点中的情况(无根造根，有根放值)。</li><li><code>Delete(key)</code>：这个与更新函数相类似，同样采取写入时复制的策略，先遍历查找key对应的值节点，然后根据情况进行删除。还需要注意删除值后如果当前节点无value且子节点为空还需要删除此节点。</li><li>并发处理：这个比较简单，只需要处理好常规的加锁问题即可。读取时考虑到获得<code>trie</code>这一步是原子性的拷贝构造，所以要为<code>root</code>专门上一把互斥锁。为了防止两个线程同时更新<code>root</code>，还需要一个<code>write</code>互斥锁。</li><li><code>Task3&amp;Task4</code>：这两个任务主要是引导我们Debug以及了解一些SQL层的相关函数，比较简单。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;写在开头&quot;&gt;&lt;a href=&quot;#写在开头&quot; class=&quot;headerlink&quot; title=&quot;写在开头&quot;&gt;&lt;/a&gt;写在开头&lt;/h2&gt;&lt;p&gt;很久没有更新了，在写学习记录和心得前，我在这里附上我学习CMU15445这门课程的链接，这是国外一门质量极高的数据库入门课程</summary>
      
    
    
    
    <category term="学习" scheme="https://galaxy-ryan.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="数据库系统" scheme="https://galaxy-ryan.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="优质课程" scheme="https://galaxy-ryan.github.io/tags/%E4%BC%98%E8%B4%A8%E8%AF%BE%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>在centos7上安装kubernetes集群环境</title>
    <link href="https://galaxy-ryan.github.io/article/2024/03/22/kubernetes-env.html/"/>
    <id>https://galaxy-ryan.github.io/article/2024/03/22/kubernetes-env.html/</id>
    <published>2024-03-22T10:35:40.000Z</published>
    <updated>2024-03-22T10:35:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>在这里我们选择Linux环境安装k8s环境，安装的版本为v1.23.x。</p><p>首先需要我们准备4台Linux服务器或者虚拟机，分别作为master，node1，node2，node3节点，最低要求为2核，2G，20G硬盘。以centos7为例对四台主机进行配置，首先进行网络的配置，我这里使用的是ens33网卡，使用vim编辑器(没有请用yum安装)编辑<code>/etc/sysconfig/network-scripts/ifcfg-ens33</code>文件，修改以下网络配置(设置静态ip)：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BOOTPROTO=<span class="string">&quot;static&quot;</span></span><br><span class="line">ONBOOT=<span class="string">&quot;yes&quot;</span></span><br><span class="line">IPADDR=192.168.153.142 <span class="comment">#自己配置的静态ip，每台主机的ip不能相同</span></span><br><span class="line">GATEWAY=192.168.153.2 <span class="comment">#网关设置</span></span><br><span class="line">DNS1=192.168.153.2 <span class="comment">#DNS服务器设置</span></span><br></pre></td></tr></table></figure><p>配置主机名，修改<code>/etc/hostname</code>文件，添加主机名，以第一台主机为例，注意不要留有空格：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">k8s-master</span><br></pre></td></tr></table></figure><p>修改每台主机的<code>/etc/hosts</code>文件，添加本地域名访问ip映射，例子如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4</span><br><span class="line">::1         localhost localhost.localdomain localhost6 localhost6.localdomain6</span><br><span class="line"></span><br><span class="line">192.168.153.142 k8s-master</span><br><span class="line">192.168.153.143 k8s-node1</span><br><span class="line">192.168.153.144 k8s-node2</span><br><span class="line">192.168.153.145 k8s-node3</span><br></pre></td></tr></table></figure><p>注意，如果是虚拟机克隆的4台机器，还需需保证4台机器的uuid与mac地址不同。到这里网络配置就结束咯！下面进行4台主机环境的配置。</p><p><strong>1.1.关闭防火墙和selinux</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld &amp;&amp; systemctl <span class="built_in">disable</span> firewalld &amp;&amp; iptables -F</span><br><span class="line">sed -i <span class="string">&#x27;s/enforcing/disabled/&#x27;</span> /etc/selinux/config &amp;&amp; setenforce 0</span><br></pre></td></tr></table></figure><p><strong>1.2.关闭swap分区</strong></p><ul><li>临时关闭</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swapoff -a</span><br></pre></td></tr></table></figure><ul><li>永久关闭swap</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -ri <span class="string">&#x27;s/.*swap.*/#&amp;/&#x27;</span> /etc/fstab</span><br></pre></td></tr></table></figure><p><strong>1.3.修改内核参数</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt; /etc/sysctl.d/k8s.conf &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-ip6tables = 1</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-iptables = 1</span></span><br><span class="line"><span class="string">net.ipv4.ip_forward = 1</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line">sysctl --system</span><br></pre></td></tr></table></figure><p><strong>1.4.加载ip_vs内核模块</strong></p><ul><li>如果kube-proxy 模式为ip_vs则必须加载，也可以采用iptables（可以不做内核ipvs加载设置）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">modprobe ip_vs</span><br><span class="line">modprobe ip_vs_rr</span><br><span class="line">modprobe ip_vs_wrr</span><br><span class="line">modprobe ip_vs_sh</span><br><span class="line">modprobe nf_conntrack_ipv4</span><br></pre></td></tr></table></figure><ul><li>设置下次开机自动加载</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt; /etc/modules-load.d/ip_vs.conf &lt;&lt; <span class="string">EOF </span></span><br><span class="line"><span class="string">ip_vs</span></span><br><span class="line"><span class="string">ip_vs_rr</span></span><br><span class="line"><span class="string">ip_vs_wrr</span></span><br><span class="line"><span class="string">ip_vs_sh</span></span><br><span class="line"><span class="string">nf_conntrack_ipv4</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure><h2 id="1-5-进行时间同步设置"><a href="#1-5-进行时间同步设置" class="headerlink" title="1.5.进行时间同步设置"></a><strong>1.5.进行时间同步设置</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 启动chronyd服务</span><br><span class="line">systemctl start chronyd</span><br><span class="line">systemctl enable chronyd</span><br><span class="line">date</span><br></pre></td></tr></table></figure><h2 id="1-6-配置完后重启各台机器"><a href="#1-6-配置完后重启各台机器" class="headerlink" title="1.6.配置完后重启各台机器"></a><strong>1.6.配置完后重启各台机器</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure><p>到这里开始进行kubernetes集群环境的搭建。</p><h2 id="2-1-所有节点安装docker-ce"><a href="#2-1-所有节点安装docker-ce" class="headerlink" title="2.1.所有节点安装docker-ce"></a><strong>2.1.所有节点安装docker-ce</strong></h2><p>这里参考阿里云镜像站安装</p><p><a href="https://developer.aliyun.com/mirror/docker-ce?spm=a2c6h.13651102.0.0.3e221b11Vnzr56">https://developer.aliyun.com/mirror/docker-ce?spm=a2c6h.13651102.0.0.3e221b11Vnzr56</a></p><p>此外，需要注意的是要配置docker的cgroupdriver：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // 添加这行</span><br><span class="line">  &quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-安装kube集群（4节点）"><a href="#2-2-安装kube集群（4节点）" class="headerlink" title="2.2.安装kube集群（4节点）"></a><strong>2.2.安装kube集群（4节点）</strong></h2><p>将所有节点的kubernetes镜像切换成国内源：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; /etc/yum.repos.d/kubernetes.repo &lt;&lt; EOF</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br><span class="line">repo_gpgcheck=0</span><br><span class="line">gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>所有节点安装指定版本 kubeadm，kubelet 和 kubectl（我这里选择<code>1.23.0</code>版本的）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yum install -y kubelet-1.23.0 kubeadm-1.23.0 kubectl-1.23.0</span><br><span class="line"></span><br><span class="line"># 设置kubelet开机启动</span><br><span class="line">systemctl enable kubelet</span><br></pre></td></tr></table></figure><p><em>更改kubelet的容器路径（如果需要的话，不需要可以跳过）</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/lib/systemd/system/kubelet.service.d/10-kubeadm.conf</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Environment=&quot;KUBELET_KUBECONFIG_ARGS=--bootstrap-kubeconfig=/etc/kubernetes/bootstrap-kubelet.conf --root-dir=/mnt/sdb_new/kubelet/ --kubeconfig=/etc/kubernetes/kubelet.conf&quot;</span><br></pre></td></tr></table></figure><p>使配置生效：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br><span class="line">systemctl restart kubelet</span><br></pre></td></tr></table></figure><h2 id="2-3-部署Kubernetes集群"><a href="#2-3-部署Kubernetes集群" class="headerlink" title="2.3.部署Kubernetes集群"></a><strong>2.3.部署Kubernetes集群</strong></h2><p><strong>覆盖kubernetes的镜像地址（只需要在master节点上操作初始化命令）。</strong></p><p>首先覆盖kubeadm的镜像地址，使用此命令列出集群在配置过程中需要哪些镜像：<code>kubeadm config images list</code></p><p>更改为阿里云的镜像地址：<code>kubeadm config images list  --image-repository registry.aliyuncs.com/google_containers</code></p><p>然后将镜像手动拉取下来，这样在初始化的时候回更快一些（还有一个办法就是直接在docker上把镜像pull下来，docker只要配置一下国内源即可快速的将镜像pull下来）：<code>kubeadm config images pull  --image-repository registry.aliyuncs.com/google_containers</code></p><p><strong>初始化kubernetes（只需要在master节点上操作初始化命令）</strong></p><p>初始化 Kubernetes，指定网络地址段和镜像地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">kubeadm init \</span><br><span class="line">  --apiserver-advertise-address=192.168.153.142 \</span><br><span class="line">  --image-repository registry.aliyuncs.com/google_containers \</span><br><span class="line">  --kubernetes-version v1.23.0 \</span><br><span class="line">  --service-cidr=10.96.0.0/12 \</span><br><span class="line">  --pod-network-cidr=10.244.0.0/16 \</span><br><span class="line">  --ignore-preflight-errors=all</span><br><span class="line"></span><br><span class="line"># –apiserver-advertise-address # 集群通告地址(master 机器IP，这里用的万兆网)</span><br><span class="line"># –image-repository # 由于默认拉取镜像地址k8s.gcr.io国内无法访问，这里指定阿里云镜像仓库地址</span><br><span class="line"># –kubernetes-version #K8s版本，与上面安装的一致</span><br><span class="line"># –service-cidr #集群内部虚拟网络，Pod统一访问入口，可以不用更改，直接用上面的参数</span><br><span class="line"># –pod-network-cidr #Pod网络，与下面部署的CNI网络组件yaml中保持一致，可以不用更改，直接用上面的参数</span><br></pre></td></tr></table></figure><p>执行完之后要手动执行一些参数（尤其是 <strong>加入集群的join命令</strong> 需要复制记录下载）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p $HOME/.kube</span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br></pre></td></tr></table></figure><p>然后使用vim编辑*&#x2F;root&#x2F;.bash_profile*文件，加入下面这段并保存：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 超级用户变量</span><br><span class="line">export KUBECONFIG=/etc/kubernetes/admin.conf</span><br><span class="line"># 设置别名</span><br><span class="line">alias k=kubectl</span><br><span class="line"># 设置kubectl命令补齐功能</span><br><span class="line">source &lt;(kubectl completion bash)</span><br></pre></td></tr></table></figure><p>激活*.bash_profile<em>文件：</em><code>source /root/.bash_profile</code>*</p><p>这段要<strong>记录</strong>下来（来自k8s初始化成功之后出现的<code>join</code>命令，需要先配置完Flannel才能加入子节点），后续子节点加入master节点需要执行这段命令，每个人的不同，这是一个示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubeadm join 192.168.153.142:6443 --token ochspx.15in9qkiu5z8tx2y \</span><br><span class="line">        --discovery-token-ca-cert-hash sha256:1f31202107af96a07df9fd78c3aa9bb44fd40076ac123e8ff28d6ab691a02a31</span><br></pre></td></tr></table></figure><p><strong>设定kubeletl网络（主节点部署）</strong></p><p>部署容器网络，CNI网络插件(在Master上执行，著名的有flannel、calico等，简单易用的实现是为CoreOS提供的flannel项目)，这里使用Flannel实现。</p><p>下载<code>kube-flannel.yml</code>：*<code>wget https://raw.githubusercontent.com/flannel-io/flannel/master/Documentation/kube-flannel.yml</code>*</p><p>然后修改配置文件，找到如下位置，修改 <code>Newwork</code> 与执行 <code>kubeadm init</code> 输入的网段一致：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">net-conf.json: |</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;Network&quot;: &quot;10.244.0.0/16&quot;,</span><br><span class="line">    &quot;Backend&quot;&quot;: &#123;</span><br><span class="line">      &quot;Type&quot;: &quot;vxlan&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改配置之后安装组件：*<code>kubectl apply -f kube-flannel.yml</code>*</p><p>查看<code>flannel pod</code>状态（必须要为<code>Running</code>状态，如果<code>kube-flannel</code>起不来，那么就用<code>kubectl describe pod</code>命令查看<code>pod</code>起不来的原因并解决）</p><p><strong>子节点加入集群（在子节点上操作）</strong></p><p>初始化会生成<code>join</code>命令，需要在<strong>子节点</strong>执行即可，以下<code>token</code>作为举例，以实际为主，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm join 192.168.153.142:6443 --token ochspx.15in9qkiu5z8tx2y         --discovery-token-ca-cert-hash sha256:1f31202107af96a07df9fd78c3aa9bb44fd40076ac123e8ff28d6ab691a02a31</span><br></pre></td></tr></table></figure><p>加入之后再在主节点查看集群中节点的状态，<strong>如果所有的节点<code>STATUS</code>都为<code>Ready</code>的话，那么到此，所有的子节点加入完成！</strong></p><p><em>补充：worker节点加入集群后无法使用kubectl命令，需要将主节点中的&#x2F;etc&#x2F;kubernetes&#x2F;admin.conf文件拷贝到从node节点相同目录下，将主节点的&#x2F;root&#x2F;.bash_profile复制到worker节点，然后source &#x2F;root&#x2F;.bash_profile</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在这里我们选择Linux环境安装k8s环境，安装的版本为v1.23.x。&lt;/p&gt;
&lt;p&gt;首先需要我们准备4台Linux服务器或者虚拟机，分别作为master，node1，node2，node3节点，最低要求为2核，2G，20G硬盘。以centos7为例对四台主机进行配置，首</summary>
      
    
    
    
    <category term="技术" scheme="https://galaxy-ryan.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="分布式系统" scheme="https://galaxy-ryan.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="环境搭建" scheme="https://galaxy-ryan.github.io/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
    <category term="容器编排" scheme="https://galaxy-ryan.github.io/tags/%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92/"/>
    
  </entry>
  
  <entry>
    <title>深度学习基础环境搭建（pytorch版）</title>
    <link href="https://galaxy-ryan.github.io/article/2024/02/07/deep-learning-env.html/"/>
    <id>https://galaxy-ryan.github.io/article/2024/02/07/deep-learning-env.html/</id>
    <published>2024-02-07T14:22:18.000Z</published>
    <updated>2024-10-07T06:22:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="anaconda安装"><a href="#anaconda安装" class="headerlink" title="anaconda安装"></a>anaconda安装</h2><p>anaconda的安装步骤比较简单，这里就直接省略了，建议采取自定义安装的形式，并且不要安装在C盘，且给安装目录文件预留50G左右的空间。</p><p>可以参考链接：<a href="https://zhuanlan.zhihu.com/p/123188004">Anaconda详细安装及使用教程（带图文）知乎</a></p><h3 id="给conda添加镜像源"><a href="#给conda添加镜像源" class="headerlink" title="给conda添加镜像源"></a>给conda添加镜像源</h3><p>先进入到base环境，键入命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda config <span class="literal">--set</span> show_channel_urls yes</span><br></pre></td></tr></table></figure><p>找到.condarc文件，如果没有，需要在<u>此电脑 - C盘 - 用户 - (你的账户名)</u>目录下新建该文件，再将下列配置写入：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">channels:</span><br><span class="line">  - defaults</span><br><span class="line">show_channel_urls: true</span><br><span class="line">default_channels:</span><br><span class="line">  - http://mirrors.aliyun.com/anaconda/pkgs/main</span><br><span class="line">  - http://mirrors.aliyun.com/anaconda/pkgs/<span class="built_in">r</span></span><br><span class="line">  - http://mirrors.aliyun.com/anaconda/pkgs/msys2</span><br><span class="line">custom_channels:</span><br><span class="line">  conda<span class="literal">-forge</span>: http://mirrors.aliyun.com/anaconda/cloud</span><br><span class="line">  msys2: http://mirrors.aliyun.com/anaconda/cloud</span><br><span class="line">  bioconda: http://mirrors.aliyun.com/anaconda/cloud</span><br><span class="line">  menpo: http://mirrors.aliyun.com/anaconda/cloud</span><br><span class="line">  pytorch: http://mirrors.aliyun.com/anaconda/cloud</span><br><span class="line">  simpleitk: http://mirrors.aliyun.com/anaconda/cloud</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后在Anaconda prompt 命令窗口运行 <code>conda clean -i </code>清除索引缓存，保证用的是镜像站提供的索引。然后输入y。</p><h3 id="给pip添加镜像源"><a href="#给pip添加镜像源" class="headerlink" title="给pip添加镜像源"></a>给pip添加镜像源</h3><p>在<u>此电脑 - C盘 - 用户 - 你的账户名</u>文件夹里创建一个pip文件夹<br>在pip 文件夹里创建 pip.ini 文件，并加入下面的配置：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">global</span>]</span><br><span class="line">index<span class="literal">-url</span> = https://pypi.mirrors.ustc.edu.cn/simple/</span><br><span class="line">extra<span class="literal">-index-url</span> = https://pypi.mirrors.ustc.edu.cn/simple/</span><br><span class="line">https://mirrors.aliyun.com/pypi/simple/</span><br><span class="line">https://pypi.tuna.tsinghua.edu.cn/simple/</span><br><span class="line">http://pypi.mirrors.ustc.edu.cn/simple/</span><br><span class="line">https://pypi.org/simple/</span><br><span class="line">trusted<span class="literal">-host</span> = pypi.mirrors.ustc.edu.cn</span><br><span class="line">pypi.mirrors.ustc.edu.cn</span><br><span class="line">mirrors.aliyun.com</span><br><span class="line">pypi.tuna.tsinghua.edu.cn</span><br><span class="line">pypi.mirrors.ustc.edu.cn</span><br><span class="line">pypi.org</span><br></pre></td></tr></table></figure><h2 id="CUDA安装"><a href="#CUDA安装" class="headerlink" title="CUDA安装"></a>CUDA安装</h2><p>这里需要电脑配备有NVIDIA的显卡(GPU)，如果没有，可以直接跳过，后续环境配置选择CPU版本即可。</p><p>在这里贴一个安装教程的链接：<a href="https://zhuanlan.zhihu.com/p/144311348">CUDA安装教程 知乎</a></p><h2 id="安装深度学习框架和软件包"><a href="#安装深度学习框架和软件包" class="headerlink" title="安装深度学习框架和软件包"></a>安装深度学习框架和软件包</h2><p>首先，你需要初始化终端Shell，以便我们可以直接运行conda。在conda的基础环境初始化完成后，关闭并重新打开当前的shell。并使用命令创建一个新的环境并激活(这里就直接命名为d2l)：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda create <span class="literal">--name</span> d2l python=<span class="number">3.9</span> <span class="literal">-y</span></span><br><span class="line">conda activate d2l</span><br></pre></td></tr></table></figure><p>我们可以按如下方式安装PyTorch的CPU或GPU版本：</p><ul><li><p>查询CUDA的版本：<code>nvcc --version</code>，后续需要根据上面cuda驱动安装的版本选择对应的pytorch版本。</p></li><li><p>进入pytorch官网，安装pytorch的GPU版本，注意选择对应的CUDA的版本，如果没有则直接选择CPU，注意这里选择conda安装的方式，复制命令并在刚刚激活环境的终端执行，这是我的版本对应命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install pytorch==<span class="number">1.11</span>.<span class="number">0</span> torchvision==<span class="number">0.12</span>.<span class="number">0</span> torchaudio==<span class="number">0.11</span>.<span class="number">0</span> cudatoolkit=<span class="number">11.3</span> <span class="literal">-c</span> pytorch</span><br></pre></td></tr></table></figure></li><li><p>安装d2l软件包，以方便调取大多数使用的函数和类，同时也需要注意自己版本：<code>pip install d2l==0.17.6</code></p></li></ul><p>安装完成后，你可以在控制台键入<code>python</code>，然后在python命令行键入下面的代码验证是否安装成功：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">查询cuda安装情况</span></span><br><span class="line"><span class="string">&quot;python控制台执行：</span></span><br><span class="line"><span class="string">!nvidia-smi</span></span><br><span class="line"><span class="string">!set cuda</span></span><br><span class="line"><span class="string">!nvcc -V</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(torch.__version__) <span class="comment"># 1.11.0</span></span><br><span class="line"><span class="built_in">print</span>(torchvision.__version__) <span class="comment"># 0.12.0</span></span><br><span class="line"></span><br><span class="line">torch.cuda.is_available()  <span class="comment"># 为True 则是cuda版本</span></span><br><span class="line">torch.device(<span class="string">&#x27;cpu&#x27;</span>), torch.device(<span class="string">&#x27;cuda&#x27;</span>), torch.device(<span class="string">&#x27;cuda:1&#x27;</span>)  <span class="comment"># 、查询可用设备</span></span><br><span class="line">torch.cuda.device_count()</span><br></pre></td></tr></table></figure><p><strong>到这里基础环境就搭建好啦！</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;anaconda安装&quot;&gt;&lt;a href=&quot;#anaconda安装&quot; class=&quot;headerlink&quot; title=&quot;anaconda安装&quot;&gt;&lt;/a&gt;anaconda安装&lt;/h2&gt;&lt;p&gt;anaconda的安装步骤比较简单，这里就直接省略了，建议采取自定义安装的形</summary>
      
    
    
    
    <category term="技术" scheme="https://galaxy-ryan.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="环境搭建" scheme="https://galaxy-ryan.github.io/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
    <category term="AI" scheme="https://galaxy-ryan.github.io/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>论文分享系列-1</title>
    <link href="https://galaxy-ryan.github.io/article/2024/02/07/readings-01.html/"/>
    <id>https://galaxy-ryan.github.io/article/2024/02/07/readings-01.html/</id>
    <published>2024-02-07T02:19:36.000Z</published>
    <updated>2024-02-07T02:19:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是一篇来自清华大学的计算机网络相关的论文阅读分享，论文名为 <em>An Efffcient Design of Intelligent Network Data Plane</em>。</p><span id="more"></span><h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>智能数据平面（IDP）：通过直接在网络数据平面上部署机器学习模型，可以使用数据驱动的模型而不是预定义的协议以线速(网络转发零减少速度)进行智能流量分析。</p><p>新兴的可编程交换机为IDP的实现提供了关键的硬件支持。 这方面的现有技术分为两大类：(i)侧重于从数据平面提取有用的流量信息，而将基于学习的流量分析放在控制平面上。 (ii) 进一步将学习模型嵌入到数据平面中，同时未能使用对于实现高学习精度至关重要的流级特征。 在本文中，提出 NetBeacon 来提高模型准确性和模型部署效率方面的最新水平。 特别是，NetBeacon 提出了一种多阶段顺序模型架构，通过合并可线速计算的流级特征来提高学习准确性，从而在流的不同阶段执行动态数据包分析。 此外，NetBeacon 设计了高效的模型表示机制，以解决在网络数据平面上部署基于树的模型时的表条目爆炸问题。 最后，NetBeacon 通过多个紧密耦合的设计来强化其处理并发流的可扩展性，以管理用于存储每个流状态的有状态存储。 实现了 NetBeacon 原型，并广泛评估了其在多个流量分析任务中的性能。</p><h2 id="问题提出"><a href="#问题提出" class="headerlink" title="问题提出"></a>问题提出</h2><p>人工智能（AI）在各种网络设计中越来越受欢迎，例如视频比特率自适应、拥塞控制、流量优化、路由和网络规划。 学习的模型通常部署在终端主机或网络控制平面上以执行推理，这些主机配备了灵活的通用处理器或 GPU。</p><p>然而，直接在网络数据平面上部署用于流量分析的学习模型是一个相对较少的领域。 例如，日益复杂的网络攻击通常绕过经验学习的流量过滤器，激励社区设计基于学习的恶意流量检测机制。 然而，与这些方法不同的是，IDP 实现了线速流量分析，而在网络控制平面上部署学习模型的最先进技术只能以大约 10 Gbps 的速度处理流量。 此外，将控制平面放置在流量分析的关键路径上会引入额外的反应时间。 除了安全域之外，其他网络设计（例如差异化路由、ECN阈值调整和缓冲区管理）也可能受益于IDP。</p><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p>NetBeacon：一种新颖的 IDP 设计，它在模型准确性和模型部署效率方面都达到了最先进的水平。NetBeacon 在流量分析&#x2F;分类精度和硬件表消耗方面均优于现有技术。具有以下创新设计：</p><p>(i) 围绕多阶段顺序模型架构的数据平面感知学习模型设计。 由于流的不同阶段的数据包携带不同的流级别状态，因此该模型在流的不同阶段进行动态分析，从而减少基于单个推理模型做出过早分类决策所引入的错误。 同时，该模型使用精心设计的流级和每数据包特征，可在数据平面上以线速计算，以确保可部署性。</p><p>(ii) NetBeacon提出了一种有效的模型表示机制，以解决将决策树或森林模型表示为数据平面匹配表时的条目爆炸问题。 与最先进的 Mousika [51] 相比，NetBeacon 显着减少了表项消耗（在某些情况下高达 75%）。</p><p>(iii) 通过区分短流和长流的处理逻辑，以及在观察存储索引冲突时允许安全存储复用，进一步强化了 NetBeacon 处理并发流的可扩展性。 这可能允许 NetBeacon 处理比用于维护每个流状态的寄存器总数更多的并发流。</p><p><strong>NetBeacon架构设计：</strong></p><p><img src="1.png" alt="架构图" loading="lazy"></p><p>从架构上来说，NetBeacon 围绕两个主要组件进行设计：数据平面感知模型设计和高效模型部署。</p><p>数据平面感知模型设计是一种生成硬件友好的学习模型的协同设计方法。 为此，该设计的特征工程依赖于在切换管道上以线速可提取或可计算的特征。 此外，考虑到流级特征（例如，数据包大小的平均值）随着流的进行而变化，NetBeacon 提出了一种多阶段顺序模型架构，可以随着流的进行而做出多个推理决策，直到系统有足够的信心做出最终决定。</p><p>模型部署的关键设计是模型表示模块。 它将学习到的模型转换为数据平面上的多个特征表和一个模型表，其中特征表将特征值编码为名为范围标记的数据结构，这些数据结构进一步映射到模型表中存储的推理结果。 NetBeacon设计了高效的编码机制，大大减少了模型表示时的表项消耗。</p><p>此外，NetBeacon还设计了状态存储管理模块，以实现数据平面上高效的每流状态管理。 一方面，该模块使 NetBeacon 能够使用纯粹的每数据包特征（即，不为短流维护每流状态）来处理短流，其中使用学习模型对短流进行分类。 另一方面，NetBeacon利用硬件哈希来实现存储复用。 特别是，当新流的5元组被散列到占用的寄存器（即存储冲突）时，如果存储的流是类确定的或超时的，则新流可以占用该寄存器； 否则，NetBeacon 会回退到对新流使用无状态每数据包功能。 如果数据包属于存储的流，则更新寄存器并计算特征以进行模型推理，即查询特征表和模型表。 一旦确定了数据包的推理结果，用户就可以根据结果设计定制的后处理，例如做出丢弃或允许的二元决策，或相应地分配细粒度的不同服务优先级。</p><h2 id="数据平面感知模型设计"><a href="#数据平面感知模型设计" class="headerlink" title="数据平面感知模型设计"></a>数据平面感知模型设计</h2><p>NetBeacon 中的决策树学习模型可以使用每数据包特征和流级特征。</p><p><img src="2.png" alt="模型学习特征" loading="lazy"></p><p><strong>包级特征</strong>即包大小、生存时间值、协议。</p><p><strong>流级特征</strong>分为聚合特征和汇总特征。 聚合特征表示为<br>$$<br>F &#x3D; aggr(a, c,d)<br>$$<br>其中 a 表示 F 中考虑的属性，c 是对该属性施加的条件，d 表示一旦数据包更新 F 值的预定规则需满足 c。例如：<br>$$<br>feature F &#x3D; aggr(packet size,[96,112),+1)<br>$$<br>记录了一个流中的数据包数量，其数据包大小在[96,112)范围内。 与聚合特征不同，汇总特征的计算不能通过预先确定的更新规则轻松表示。 代表性的汇总特征是最大值&#x2F;最小值、平均值和方差，甚至涉及硬件本身不支持的乘法或除法。流级特征是通过组合同一流中其他数据包的属性来获得的，一般来说，把具有相同五元组（源 IP 地址、源端口号、目的 IP 地址、目的端口号、协议号）的数据包集合定义为一条流。</p><p><img src="3.png" alt="特征编码" loading="lazy"></p><p>数据平面感知模型将范围特征进行特定的编码，解决了上面三元条目组合爆炸问题以及交换机不支持范围匹配的问题。</p><p><img src="4.png" alt="编码方式" loading="lazy"></p><h2 id="多阶段顺序模型"><a href="#多阶段顺序模型" class="headerlink" title="多阶段顺序模型"></a>多阶段顺序模型</h2><p>NetBeacon坚持基于决策树的学习模型，采用最先进的决策树森林模型，即随机森林（RF）和XGBoost（XGB）。 同时考虑到硬件上表项的数量是有限的，通过限制森林中的树数、最大树深度、最大叶子数等来控制模型大小。</p><p><img src="5.png" alt="集成学习" loading="lazy"></p><p>他们设计了一个多阶段模型架构，以便在流程的不同阶段应用不同的模型。 在每个阶段，NetBeacon 使用该阶段计算的特征进行训练和推理，即第 n 个数据包的流级特征是根据前 n 个数据包计算的。该模型做出推理决策的数据包称为推理点。 推理点的精确排列取决于任务。 特别是，每个推理点本质上代表了该模型处理推理点之前的 n 个数据包之后流的分析结果。 因此，可以根据任务统一或具体地放置推理点。NetBeacon 为每个推理阶段设置确定阈值。 当特定推理点的分类概率高于相应的确定阈值时，表明多阶段顺序模型有信心在不使用后续推理点的情况下预先确定流的类别。</p><p>从单个决策树的数据平面表示开始。 在决策树中，叶子节点代表分类结果，从根节点到叶子节点的路径代表该叶子节点的匹配规则，通常是多个特征范围的串联。如图 6 中的模型表（1）所示，其中键是多个特征范围的串联，值是叶节点。NetBeacon 通过引入一种名为范围标记的新颖机制解决了上述条目组合爆炸问题。决策树模型表示为多个特征表（每个特征一个）和一个模型表。 范围标记机制确保每个叶节点仅消耗模型表中的单个三元条目，无论有多少特征表条目与该叶节点相关。从范围匹配（1）到三元匹配（2），表示叶 5 的表条目数从 1 增加到 48（8 × 1 × 6）。 在 NetBeacon 中，每个叶子仅消耗模型表中的 1 个条目。 特征表由所有叶子共享，并且它们的条目通过新颖的范围编码算法（CRC）减少。</p><p>NetBeacon 不是单独表示各个树，而是合并它们的模型表示。 具体来说，给定特征 f1，每个单独的树都可以有一个特征表。 合并这些特征表与使用该范围标记算法考虑这些表中出现的所有特征值范围来创建新的特征表相同。 对于模型表，每个条目代表各个树的叶子的一种组合。 因此，模型表条目的关键是通过考虑到与该条目关联的叶子的路径上的所有节点（代表特征范围）而获得的范围标记，并且对应的值是这些叶子的聚合（例如，Sigmoid） ，可以离线计算。 例如，图 9 中的叶子 1-2 和叶子 2-1 的组合将 f1 ∈ [25,256) 和 f1 ∈ [0,35) 合并，形成 f1 ∈ [25,35)。 组合的值为Sigmoid(-0.01+0.5)。</p><h2 id="多阶段模型推理"><a href="#多阶段模型推理" class="headerlink" title="多阶段模型推理"></a>多阶段模型推理</h2><p>该多阶段顺序模型架构在不同的推理点应用不同的模型。 直观上， 用自己的特征表和模型表分别表示每个阶段的每个模型。 或者，可以合并它们的表示。 如图所示，特征表和模型表都有一个名为total_packets的额外键，用于区分不同阶段的模型。 考虑到这些模型可能使用不同的特征，如果某个特征未被特定模型使用，则将该特征的范围标记设置为*来表示任意范围标记。 一般来说，模型推理分为两个阶段：一个阶段用于并行匹配特征表，一个阶段用于匹配（聚合）模型表。</p><p><img src="6.png" alt="模型推理" loading="lazy"></p><h2 id="有状态存储"><a href="#有状态存储" class="headerlink" title="有状态存储"></a>有状态存储</h2><p>为了利用流级功能，NetBeacon 依靠有状态存储来维护每个流的状态。 涉及控制平面在接收新流时分配不冲突的存储索引。 为了实现线速流量分析，NetBeacon 依赖于数据平面上随时可用的硬件哈希来分配存储索引。 特别是，假设有 N 个有状态寄存器可用于存储流状态，NetBeacon 将流的存储索引计算为 H（5 元组）% N，其中 H 是哈希函数。 然而，基于哈希的存储索引分配存在分配冲突的问题，即两个不同的流（具有不同的五元组）可能接收相同的存储索引。 因此，有必要将真实的流 ID（例如，5 元组）与存储索引一起存储，以便 NetBeacon 意识到冲突。 一旦发生存储冲突，如果新流覆盖存储，则原始流和新流的每流状态都将变脏。 因此，NetBeacon 提出了两种设计来缓解这一问题：一种设计可减少总体冲突几率，另一种设计可实现安全存储覆盖。</p><p>区分短流和长流。 在每个数据包特征之上合并成流级特征的原因是为了提高分类准确性。 由于流量分析的主要目标是提高所有流的总体数据包分类准确性，因此为具有较少数据包的较短流维护每流状态的边际回报比为较长流维护每流状态的边际收益要低。 NetBeacon引入了一种长短流二元分类模型，仅使用每个数据包的特征来判断数据包是否属于长流，并且长短流二元分类模型是特定于任务的。</p><p>处理存储索引冲突。 当存储索引发生冲突时，如果现有流的推理类已确定或流已完成（即，其最后一个数据包到达时间超过预定义的超时），NetBeacon 允许新流使用占用的寄存器。 否则，NetBeacon 将回退到对新流使用每数据包无状态功能。 如果流已通过多阶段顺序模型中定义的最后一个推理点，或者模型对流在中间推理点的推理结果有足够的信心，则确定流的推理类&#x2F;结果，将流的推理结果保存在流类表中，并以流的 5 元组为关键字，以匹配该流中的后续数据包。 同时，它更新流的存储以标记其推理结果已确定，表明占用的寄存器已准备好在存储索引冲突时被未来流覆盖。 在从数据平面接收到指示流的类别已确定的消息后，控制平面将新条目动态插入到流类别表中。 同时，需要定期删除流类表中的一些条目（基于 FIFO 或 LRU 原则）以防止表溢出。</p><h2 id="集成的数据平面处理逻辑"><a href="#集成的数据平面处理逻辑" class="headerlink" title="集成的数据平面处理逻辑"></a>集成的数据平面处理逻辑</h2><p><img src="7.png" alt="数据平面" loading="lazy"></p><p>当数据包 P 到达时，其流哈希 H1 通过对数据包的 5 元组进行哈希计算（算法 1 中的第 1 行）。 然后哈希值的最后 IndexSize 位被用作存储索引 Sid（算法 1 中的第 2 行）。 如果 P 是正常数据包（即，不是重新提交数据包，如下所述），则它与流类别表 TClass 匹配（算法 1 中的第 4 行）。 如果匹配，则直接将数据包的推理结果&#x2F;类别指定为匹配的类别。</p><p>否则，NetBeacon 检查状态存储中是否已为数据包 P 分配了每流状态存储。 为此，它使用 Sid 检索存储的真实流 ID（例如，5 元组）并将其与 P 的流 ID 进行比较。 如果它们相等，NetBeacon 会识别出存储在 Sid 的流的新数据包，然后相应地更新流的状态。 同时，如果P恰好是推理点，NetBeacon会计算流级特征Ff，NetBeacon根据流级特征Ff，以及从P中提取的每包Fp进行模型推理。如果分类概率大于预定义的 阈值dt，流的类别被确定。 之后，数据平面首先更新流的存储Regsure以指示其类别已确定，然后通知控制平面将流插入流类别表中。 如果P不是推理点，则使用存储的推理结果（即最近的推理点得到的结果）作为自己的分类结果。 相反，如果 P 属于没有现有存储的流，则 NetBeacon 仅使用 P 的每个数据包特征来获取其分类结果。如果 P 被分类为长流数据包，NetBeacon 将检查 Sid 上的存储是否为空或已存在。 准备被覆盖。 如果是，NetBeacon 使用 Sid 索引的存储来启动 P 流的每流状态。 因此，当存储的流被类确定（或超时）时，存储寄存器被延迟释放，同时新的流被散列到寄存器。 在整个流量分析过程中，NetBeacon 使用重新提交的数据包 (i) 更新现有流的新推理结果或 (ii) 启动新流的存储。 由于Resubmit的目的是触发前阶段寄存器的修改（而不是修改数据包本身），因此我们可以通过将数据包镜像到环回端口来触发修改，而不是重新提交或重新循环，这样原始数据包就不会被修改。 延迟。 此外，只有触发推理结果更新的推理点数据包才会被镜像，仅占数据包的一小部分。</p><h2 id="控制平面逻辑"><a href="#控制平面逻辑" class="headerlink" title="控制平面逻辑"></a>控制平面逻辑</h2><p>在NetBeacon中，控制平面负责：（i）从一开始就在数据平面上安装特征表和模型表，（ii）在接收到来自数据的请求时更新流类表确定流级时的平面。 当然，更新流类别表的延迟不会影响流量分析，因为与流类别表不匹配的数据包将改为遍历常规模型推理管道。 因此，控制平面脱离了 NetBeacon 中数据包分类的关键路径，保证了线速流量分析。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这是一篇来自清华大学的计算机网络相关的论文阅读分享，论文名为 &lt;em&gt;An Efffcient Design of Intelligent Network Data Plane&lt;/em&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="学习" scheme="https://galaxy-ryan.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="计算机网络" scheme="https://galaxy-ryan.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="机器学习" scheme="https://galaxy-ryan.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="论文分享" scheme="https://galaxy-ryan.github.io/tags/%E8%AE%BA%E6%96%87%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>Scala语法特性-函数式编程</title>
    <link href="https://galaxy-ryan.github.io/article/2024/01/31/Scala-1.html/"/>
    <id>https://galaxy-ryan.github.io/article/2024/01/31/Scala-1.html/</id>
    <published>2024-01-31T06:10:34.000Z</published>
    <updated>2024-01-31T06:10:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><h3 id="函数式编程特点："><a href="#函数式编程特点：" class="headerlink" title="函数式编程特点："></a>函数式编程特点：</h3><p>函数式编程是一种<strong>编程范式</strong>，属于”结构化编程”的一种，主要思想是把运算过程写成一系列的函数调用。即将函数当做数据类型，可以接受函数当做输入(参数)或输出(返回值)。</p><p><strong>函数作为参数进行传递</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args:<span class="type">Array</span>[<span class="type">String</span>]):<span class="type">Unit</span> = &#123;</span><br><span class="line">      </span><br><span class="line">       <span class="function"><span class="keyword">def</span> <span class="title">fun</span></span>(f : (<span class="type">Int</span>,<span class="type">Int</span>)=&gt;<span class="type">Int</span>,a:<span class="type">Int</span>,b:<span class="type">Int</span>) :<span class="type">Int</span> = &#123;</span><br><span class="line">         f(a,b)</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">def</span> <span class="title">add</span> </span>(a:<span class="type">Int</span>,b:<span class="type">Int</span>):<span class="type">Int</span> = &#123;</span><br><span class="line">         a + b</span><br><span class="line">       &#125;</span><br><span class="line">       fun(add,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">       fun((a,b)=&gt;a+b,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">       fun(_+_,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>函数作为函数返回值返回</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args:<span class="type">Array</span>[<span class="type">String</span>]):<span class="type">Unit</span> = &#123;</span><br><span class="line">      <span class="comment">// 在这个示例中，f6函数作为f5的返回值</span></span><br><span class="line">          <span class="function"><span class="keyword">def</span> <span class="title">f5</span></span>(): <span class="type">Int</span> =&gt; <span class="type">Int</span> = &#123;</span><br><span class="line">              <span class="function"><span class="keyword">def</span> <span class="title">f6</span></span>(a:<span class="type">Int</span>):<span class="type">Int</span> = &#123;</span><br><span class="line">                a + <span class="number">1</span></span><br><span class="line">              &#125;</span><br><span class="line">              f6</span><br><span class="line">          &#125;</span><br><span class="line">          f5()(<span class="number">2</span>)</span><br><span class="line">          <span class="comment">// 上面定义的f6函数可以按照如下步骤进行简化</span></span><br><span class="line">          <span class="function"><span class="keyword">def</span> <span class="title">f5</span></span>(): <span class="type">Int</span> =&gt; <span class="type">Int</span> = &#123;</span><br><span class="line">               a =&gt; a + <span class="number">1</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="function"><span class="keyword">def</span> <span class="title">f5</span></span>()(a:<span class="type">Int</span>) = &#123;</span><br><span class="line">              a+<span class="number">1</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="function"><span class="keyword">def</span> <span class="title">f5</span></span>()(a:<span class="type">Int</span>)= a + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数至简原则"><a href="#函数至简原则" class="headerlink" title="函数至简原则"></a>函数至简原则</h3><ul><li><p>return 可以省略，Scala 会使用函数体的最后一行代码作为返回值。</p></li><li><p>如果函数体只有一行代码，可以省略花括号。</p></li><li><p>返回值类型如果能够推断出来，那么可以省略（:和返回值类型一起省略）。</p></li><li><p>如果有 return，则不能省略返回值类型，必须指定。</p></li><li><p>如果函数明确声明 unit，那么即使函数体中使用 return 关键字也不起作用。</p></li><li><p>Scala 如果期望是无返回值类型，可以省略等号，将无返回值的函数称之为过程。</p></li><li><p>如果函数无参，但是声明了参数列表，那么调用时，小括号，可加可不加。</p></li><li><p>如果函数没有参数列表，那么小括号可以省略，调用时小括号必须省略。</p></li></ul><h3 id="函数的闭包"><a href="#函数的闭包" class="headerlink" title="函数的闭包"></a>函数的闭包</h3><p>如果一个函数，访问到了它的外部（局部）变量的值，那么这个函数和他所处的环境，称为闭包。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args:<span class="type">Array</span>[<span class="type">String</span>]):<span class="type">Unit</span> = &#123;</span><br><span class="line">         <span class="function"><span class="keyword">def</span> <span class="title">fun</span></span>(a:<span class="type">Int</span>):<span class="type">Int</span>=&gt;<span class="type">Int</span> = &#123;</span><br><span class="line">           <span class="function"><span class="keyword">def</span> <span class="title">func</span></span>(b:<span class="type">Int</span>):<span class="type">Int</span> = &#123;</span><br><span class="line">             a + b</span><br><span class="line">           &#125;</span><br><span class="line">           func</span><br><span class="line">         &#125;</span><br><span class="line">         fun(<span class="number">5</span>)(<span class="number">6</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h3><p>把一个参数列表的多个参数，变成多个参数列表。</p><p><strong>与闭包的关系：</strong>闭包可以通过简化得到。函数柯里化一定存在闭包。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args:<span class="type">Array</span>[<span class="type">String</span>]):<span class="type">Unit</span> = &#123;</span><br><span class="line">         <span class="function"><span class="keyword">def</span> <span class="title">fun</span></span>(a:<span class="type">Int</span>):<span class="type">Int</span>=&gt;<span class="type">Int</span> = b =&gt; a + b</span><br><span class="line">         <span class="comment">// 上面的函数如果要省略返回值的话可以写成柯里化形式</span></span><br><span class="line">         <span class="function"><span class="keyword">def</span> <span class="title">fun</span></span>(a:<span class="type">Int</span>)(b:<span class="type">Int</span>) = a + b</span><br><span class="line">         fun(<span class="number">5</span>)(<span class="number">6</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="控制抽象"><a href="#控制抽象" class="headerlink" title="控制抽象"></a>控制抽象</h3><p>这里记录函数的几种调用方式：</p><p><strong>值调用(call-by-value)</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把计算后的值传递过去</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args:<span class="type">Array</span>[<span class="type">String</span>]):<span class="type">Unit</span> = &#123;</span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">foo</span></span>(a:<span class="type">Int</span>):<span class="type">Unit</span> = &#123;</span><br><span class="line">       println(a)</span><br><span class="line">     &#125;</span><br><span class="line">     foo(<span class="number">4</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>名调用(call-by-name)</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把代码块传递过去(重要)</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args:<span class="type">Array</span>[<span class="type">String</span>]):<span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">foo</span></span>(a: =&gt; <span class="type">Unit</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">          a</span><br><span class="line">        &#125;</span><br><span class="line">        foo&#123;println(<span class="string">&quot;名调用&quot;</span>)&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">fun</span></span>(condition: =&gt; <span class="type">Boolean</span>): (=&gt; <span class="type">Unit</span>) =&gt; <span class="type">Unit</span> = &#123;</span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">loop</span></span>(operation: =&gt; <span class="type">Unit</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">          operation</span><br><span class="line">          fun(condition)(operation)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      loop</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用匿名函数简化</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fun2</span></span>(condition: =&gt; <span class="type">Boolean</span>): (=&gt; <span class="type">Unit</span>) =&gt; <span class="type">Unit</span> = &#123;</span><br><span class="line">      operation =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">          operation</span><br><span class="line">          fun2(condition)(operation)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//使用函数柯里化简化</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fun3</span></span>(condition: =&gt; <span class="type">Boolean</span>)(operation: =&gt; <span class="type">Unit</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">      <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">        operation</span><br><span class="line">        fun3(condition)(operation)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//类似实现while循环的效果</span></span><br><span class="line">    <span class="keyword">var</span> n = <span class="number">5</span></span><br><span class="line">    fun3(n &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">      println(n)</span><br><span class="line">      n -= <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="惰性加载"><a href="#惰性加载" class="headerlink" title="惰性加载"></a>惰性加载</h3><p>函数的惰性加载，即当函数返回值被声明为 lazy 时，函数的执行将被推迟，直到我们首次对此取值，该函数才会执行。lazy 不能修饰 var 类型的变量。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"> <span class="keyword">lazy</span> <span class="keyword">val</span> res = sum(<span class="number">10</span>, <span class="number">30</span>)</span><br><span class="line"> println(<span class="string">&quot;----------------&quot;</span>)</span><br><span class="line"> println(<span class="string">&quot;res=&quot;</span> + res)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span></span>(n1: <span class="type">Int</span>, n2: <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line"> println(<span class="string">&quot;sum 被执行...&quot;</span>)</span><br><span class="line"> <span class="keyword">return</span> n1 + n2</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果应为：</span></span><br><span class="line"><span class="comment">// ----------------</span></span><br><span class="line"><span class="comment">// sum 被执行...</span></span><br><span class="line"><span class="comment">// res=40</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;函数式编程&quot;&gt;&lt;a href=&quot;#函数式编程&quot; class=&quot;headerlink&quot; title=&quot;函数式编程&quot;&gt;&lt;/a&gt;函数式编程&lt;/h2&gt;&lt;h3 id=&quot;函数式编程特点：&quot;&gt;&lt;a href=&quot;#函数式编程特点：&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="学习" scheme="https://galaxy-ryan.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="大数据" scheme="https://galaxy-ryan.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    <category term="编程语言" scheme="https://galaxy-ryan.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Scala语法特性-面向对象</title>
    <link href="https://galaxy-ryan.github.io/article/2024/01/31/Scala-2.html/"/>
    <id>https://galaxy-ryan.github.io/article/2024/01/31/Scala-2.html/</id>
    <published>2024-01-31T06:00:19.000Z</published>
    <updated>2024-01-31T06:00:19.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><p><strong>特殊：在 Scala 中可以为每个包定义一个同名的包对象，定义在包对象中的成员，作为其对应包下所有 class 和 object 的共享变量，可以被直接访问。</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> <span class="class"><span class="keyword">object</span> <span class="title">com</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> shareValue=<span class="string">&quot;share&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shareMethod</span></span>()=&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如上面定义的包对象可以使用在com包下的任何位置上。</span></span><br></pre></td></tr></table></figure><h3 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h3><ul><li><p>Scala中属性和方法的默认访问权限为public，但Scala中没有public关键字。</p></li><li><p>private为私有权限，只能在本类中或当前类的伴生对象中访问。</p></li><li><p>private[this] 只能在本类中访问，伴生对象中也不能访问。</p></li><li><p>protected为受保护权限，Scala中受保护权限比Java中更严格，可以在本类、子类、子类伴生对象中访问，同包无法访问。</p></li><li><p>protected[this] 只能在本类、子类中访问（子类伴生对象中无法访问）</p></li><li><p>private[包名]增加包访问权限，包名下的其他类也可以使用。</p></li></ul><h3 id="定义类和属性"><a href="#定义类和属性" class="headerlink" title="定义类和属性"></a>定义类和属性</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义类</span></span><br><span class="line">[<span class="keyword">private</span>[包名]|<span class="keyword">protected</span>] <span class="class"><span class="keyword">class</span> <span class="title">类名</span></span>&#123;</span><br><span class="line">   类体</span><br><span class="line">   <span class="comment">// 属性是类的一个组成部分</span></span><br><span class="line">  <span class="comment">// 在属性上面增加@BeanProperty注解的话，可以自动生成getter/setter方法，为了兼容一些需要使用到getter/setter方法的场景。</span></span><br><span class="line">  [<span class="keyword">private</span>] <span class="keyword">var</span>|<span class="keyword">val</span> 属性名称 [：属性类型] = 属性值</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以把类的属性声明在类的后面。</span></span><br><span class="line"><span class="comment">// 这里的private关键字相当于把这个类的构造器私有化，这样只能通过这个类的伴生对象来创建。直接在类后面声明属性的时候修饰符val和var的作用相同。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>[private](<span class="params">val name:<span class="type">String</span>,var age:<span class="type">Int</span></span>)</span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在属性上增加@BeanProperty注解可以自动给属性生成getter/setter方法.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">  <span class="meta">@BeanProperty</span></span><br><span class="line">  <span class="keyword">var</span> name:<span class="type">String</span> = _</span><br><span class="line">  <span class="keyword">var</span> age:<span class="type">Int</span> = _</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 属性定义为私有属性，可以通过伴生对象进行调用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>[private](<span class="params">var name:<span class="type">String</span>,var age:<span class="type">Int</span></span>)</span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定义方法"><a href="#定义方法" class="headerlink" title="定义方法"></a>定义方法</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">方法名</span></span>(参数:参数类型,参数:参数类型,...):返回值 = &#123;&#125;</span><br><span class="line"><span class="comment">// 在Scala中，函数的定义和方法的定义类似。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法调用的四种方式</span></span><br><span class="line"><span class="comment">//    方式一：后缀调用法</span></span><br><span class="line"><span class="comment">//      例如: 1.+(10)</span></span><br><span class="line"><span class="comment">//    方式二：中缀调用法</span></span><br><span class="line"><span class="comment">//      例如：1 + 10</span></span><br><span class="line"><span class="comment">//    方式三：花括号调用法 方法只有一个参数，才能使用花括号调用法，通常参数的类型是函数（方法）</span></span><br><span class="line"><span class="comment">//      例如：</span></span><br><span class="line"><span class="comment">//    方式四：无括号调用法 如果方法没有参数，可以省略方法名后面的括号</span></span><br><span class="line"><span class="comment">//      例如：println</span></span><br></pre></td></tr></table></figure><h2 id="继承、封装与多态"><a href="#继承、封装与多态" class="headerlink" title="继承、封装与多态"></a>继承、封装与多态</h2><p>继承、封装与多态与Java类似，需要注意Scala权限修饰默认为public，Scala 中多态属性和方法都是动态绑定,而 Java 中只有方法为动态绑定，属性为静态绑定。</p><h2 id="单例对象（伴生对象）"><a href="#单例对象（伴生对象）" class="headerlink" title="单例对象（伴生对象）"></a>单例对象（伴生对象）</h2><p><strong>特殊：</strong>Scala语言是完全面向对象的语言，所以并没有静态的操作（即在Scala中没有静态的概念）。但是为了能够和Java语言交互（因为Java中有静态概念），就产生了一种特殊的对象来模拟类对象，该对象为单例对象(伴生对象)。若单例对象名与类名一致，则称该单例对象为这个类的伴生对象，这个类为伴生对象的伴生类。伴生类和伴生对象的名称应该完全一致。这个类的所有“静态”内容都可以放置在它的伴生对象中声明。单例对象中的属性和方法都可以通过伴生对象名（类名）直接调用访问。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伴生对象采用 object 关键字声明</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> country: <span class="type">String</span> = <span class="string">&quot;China&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 伴生对象对应的类称之为伴生类，伴生对象的名称应该和伴生类名一致。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> name: <span class="type">String</span> = <span class="string">&quot;bobo&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">       <span class="comment">// 伴生对象中的属性和方法都可以通过伴生对象名（类名）直接调用访问。</span></span><br><span class="line">       println(<span class="type">Person</span>.country)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>同时通过伴生对象的 apply 方法，可以实现不使用 new 关键字创建对象：</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">         <span class="comment">//通过伴生对象的 apply 方法，实现不使用 new 关键字创建对象。</span></span><br><span class="line">         <span class="keyword">val</span> p1 = <span class="type">Person</span>()</span><br><span class="line">         println(<span class="string">&quot;p1.name=&quot;</span> + p1.name)</span><br><span class="line">         <span class="keyword">val</span> p2 = <span class="type">Person</span>(<span class="string">&quot;bobo&quot;</span>)</span><br><span class="line">         println(<span class="string">&quot;p2.name=&quot;</span> + p2.name)</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果想让主构造器变成私有的，可以在()之前加上 private</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="title">private</span>(<span class="params">var name: <span class="type">String</span></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(): <span class="type">Person</span> = &#123;</span><br><span class="line">         println(<span class="string">&quot;apply 空参被调用&quot;</span>)</span><br><span class="line">         <span class="keyword">new</span> <span class="type">Person</span>(<span class="string">&quot;xx&quot;</span>)</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(name: <span class="type">String</span>): <span class="type">Person</span> = &#123;</span><br><span class="line">         println(<span class="string">&quot;apply 有参被调用&quot;</span>)</span><br><span class="line">         <span class="keyword">new</span> <span class="type">Person</span>(name)</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="特质"><a href="#特质" class="headerlink" title="特质"></a>特质</h2><p>Scala 语言中，采用特质 trait（特征）来代替接口的概念，也就是说，多个类具有相同的特质（特征）时，就可以将这个特质（特征）独立出来，采用关键字 trait 声明。Scala 中的 trait 中即可以有抽象属性和方法，也可以有具体的属性和方法，一个类可以混入（mixin）多个特质。类似于 Java 中的抽象类。Scala 引入 trait 特征，第一可以替代 Java 的接口，第二个也是对单继承机制的一种补充。在每一个trait中都只存在一个主构造器，并且这个主构造器是无参的。</p><p>一个类具有某种特质（特征），就意味着这个类满足了这个特质（特征）的所有要素，所以在使用时，也采用了 extends 关键字，如果有多个特质或存在父类，那么需要采用with关键字连接。类和特质之间是继承的关系。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">特质名</span> </span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">主体</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">类名</span> <span class="keyword">extends</span> <span class="title">特质</span> 1 <span class="keyword">with</span> <span class="title">特质</span> 2 <span class="keyword">with</span> <span class="title">特质</span> 3 <span class="title">…</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">类名</span> <span class="keyword">extends</span> <span class="title">父类</span> <span class="keyword">with</span> <span class="title">特质</span> 1 <span class="keyword">with</span> <span class="title">特质</span> 2 <span class="keyword">with</span> <span class="title">特质</span> 3<span class="title">…</span></span></span><br></pre></td></tr></table></figure><p>特质可以同时拥有抽象方法和具体方法，并且所有的 Java 接口都可以当做 Scala 特质使用。为了更灵活的扩展类的功能，特质还可以采取动态混入，即在创建对象使混入特质。此外，特质还采取特质叠加的方式来解决类冲突，即将混入的多个 trait 中的冲突方法叠加起来。特质叠加示例如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Ball</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">describe</span></span>(): <span class="type">String</span> = &#123;</span><br><span class="line">    <span class="string">&quot;ball&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Color</span> <span class="keyword">extends</span> <span class="title">Ball</span> </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">describe</span></span>(): <span class="type">String</span> = &#123;</span><br><span class="line">    <span class="string">&quot;blue-&quot;</span> + <span class="keyword">super</span>.describe()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Category</span> <span class="keyword">extends</span> <span class="title">Ball</span> </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">describe</span></span>(): <span class="type">String</span> = &#123;</span><br><span class="line">    <span class="string">&quot;foot-&quot;</span> + <span class="keyword">super</span>.describe()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyBall</span> <span class="keyword">extends</span> <span class="title">Category</span> <span class="keyword">with</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">describe</span></span>(): <span class="type">String</span> = &#123;</span><br><span class="line">    <span class="string">&quot;my ball is a &quot;</span> + <span class="keyword">super</span>.describe()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestTrait</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(<span class="keyword">new</span> <span class="type">MyBall</span>().describe())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line"><span class="comment">// my ball is a blue-foot-ball</span></span><br><span class="line"><span class="comment">// 当一个类混入多个特质的时候，Scala 会对所有的特质及其父特质按照一定的顺序进行排序，而此案例中的 super.describe()调用的实际上是排好序后的下一个特质中的 describe()方法。，排序规则如下：</span></span><br><span class="line">   <span class="comment">// MyBall -&gt; Color -&gt; Category -&gt; Ball</span></span><br></pre></td></tr></table></figure><p>上述示例中的 super，不是表示其父特质对象，而是表示上述叠加顺序中的下一个特质，即，MyBall 中的 super 指代 Color，Color 中的 super 指代 Category，Category 中的 super指代 Ball。 如果想要调用某个指定的混入特质中的方法，可以增加约束：super[]，例如：super[Category].describe()。 指定调用只能指定自身的父类，父类的父类不能指定。</p><h2 id="类型检查和转换"><a href="#类型检查和转换" class="headerlink" title="类型检查和转换"></a>类型检查和转换</h2><ul><li>obj.isInstanceOf[T]：判断 obj 是不是 T 类型。</li><li>obj.asInstanceOf[T]：将 obj 类型强转成 T 类型。</li><li>classOf和getClass： 获取对象的类名。</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Person</span> </span>&#123; </span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123; </span><br><span class="line">     <span class="keyword">val</span> person = <span class="keyword">new</span> <span class="type">Person</span> </span><br><span class="line">     <span class="comment">// 判断对象是否为某个类型的实例 </span></span><br><span class="line">     <span class="keyword">val</span> bool: <span class="type">Boolean</span> = person.isInstanceOf[<span class="type">Person</span>] </span><br><span class="line">     <span class="keyword">if</span> ( bool ) &#123; </span><br><span class="line">     <span class="comment">// 将对象转换为某个类型的实例 </span></span><br><span class="line">     <span class="keyword">val</span> p1: <span class="type">Person</span> = person.asInstanceOf[<span class="type">Person</span>] </span><br><span class="line">         println(p1)</span><br><span class="line">         println(p1.getClass)</span><br><span class="line">     &#125; </span><br><span class="line">     <span class="comment">// 获取类的信息 </span></span><br><span class="line">     <span class="keyword">val</span> pClass: <span class="type">Class</span>[<span class="type">Person</span>] = classOf[<span class="type">Person</span>] </span><br><span class="line">         println(pClass) </span><br><span class="line">     &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;类和对象&quot;&gt;&lt;a href=&quot;#类和对象&quot; class=&quot;headerlink&quot; title=&quot;类和对象&quot;&gt;&lt;/a&gt;类和对象&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;特殊：在 Scala 中可以为每个包定义一个同名的包对象，定义在包对象中的成员，作为其对应包下所有 clas</summary>
      
    
    
    
    <category term="学习" scheme="https://galaxy-ryan.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="大数据" scheme="https://galaxy-ryan.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    <category term="编程语言" scheme="https://galaxy-ryan.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Scala语法特性-其他</title>
    <link href="https://galaxy-ryan.github.io/article/2024/01/31/Scala-3.html/"/>
    <id>https://galaxy-ryan.github.io/article/2024/01/31/Scala-3.html/</id>
    <published>2024-01-31T05:34:27.000Z</published>
    <updated>2024-01-31T05:34:27.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h2><p><strong>基本语法：</strong></p><p>模式匹配语法中，采用 match 关键字声明，每个分支采用 case 关键字进行声明，当需要匹配时，会从第一个 case 分支开始，如果匹配成功，那么执行对应的逻辑代码，如果匹配不成功，继续执行下一个分支进行判断。如果所有 case 都不匹配，那么会执行 case _分支，类似于 Java 中 default 语句。</p><p>每个 case 中，不需要使用 break 语句，自动中断 case。match case 语句可以匹配任何类型，而不只是字面量。</p><p>&#x3D;&gt; 后面的代码块，直到下一个 case 语句之前的代码是作为一个整体执行，可以使用{}括起来，也可以不括。</p><p><strong>模式守卫：</strong></p><p>如果想要表达匹配某个范围的数据，就需要在模式匹配中增加条件守卫。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestMatchGuard</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">       <span class="function"><span class="keyword">def</span> <span class="title">abs</span></span>(x: <span class="type">Int</span>) = x <span class="keyword">match</span> &#123;</span><br><span class="line">       <span class="keyword">case</span> i: <span class="type">Int</span> <span class="keyword">if</span> i &gt;= <span class="number">0</span> =&gt; i</span><br><span class="line">       <span class="keyword">case</span> j: <span class="type">Int</span> <span class="keyword">if</span> j &lt; <span class="number">0</span> =&gt; -j</span><br><span class="line">       <span class="keyword">case</span> _ =&gt; <span class="string">&quot;type illegal&quot;</span></span><br><span class="line">       &#125;</span><br><span class="line">       println(abs(<span class="number">-5</span>))</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>匹配样例类：</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> (<span class="params">name: <span class="type">String</span>, age: <span class="type">Int</span></span>)</span></span><br></pre></td></tr></table></figure><p>样例类仍然是类，和普通类相比，只是其自动生成了伴生对象，并且伴生对象中自动提供了一些常用的方法，如 apply、unapply、toString、equals、hashCode 和 copy。<br>样例类是为模式匹配而优化的类，因为其默认提供了 unapply 方法，因此，样例类可以直接使用模式匹配，而无需自己实现 unapply 方法。(unapply方法算是apply方法的反向操作。unapply接受一个对象，然后从对象中提取值，提取的值通常是用来构造该对象的值。)<br>构造器中的每一个参数都成为 val，除非它被显式地声明为 var（不建议这样做）。</p><p><strong>偏函数中的模式匹配：</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 偏函数定义</span></span><br><span class="line"><span class="keyword">val</span> second: <span class="type">PartialFunction</span>[<span class="type">List</span>[<span class="type">Int</span>], <span class="type">Option</span>[<span class="type">Int</span>]] = &#123;</span><br><span class="line">    <span class="keyword">case</span> x :: y :: _ =&gt; <span class="type">Some</span>(y)</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 该偏函数的功能是返回输入的 List 集合的第二个元素</span></span><br><span class="line">  <span class="comment">// 偏函数就是被包在花括号中，没有match的一组case语句，偏函数是PartialFunction[A,B]的一个实例，A代表输入数值，B代表输出数值</span></span><br><span class="line">  <span class="comment">//示例如下：</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> list: <span class="type">List</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = <span class="type">List</span>((<span class="string">&quot;a&quot;</span>, <span class="number">12</span>), (<span class="string">&quot;b&quot;</span>, <span class="number">35</span>), (<span class="string">&quot;c&quot;</span>, <span class="number">27</span>), (<span class="string">&quot;a&quot;</span>, <span class="number">13</span>))</span><br><span class="line">     <span class="comment">// 1. map转换，实现key不变，value成2倍</span></span><br><span class="line">    <span class="keyword">val</span> newList = list.map(tuple =&gt; (tuple._1, tuple._2 * <span class="number">2</span>))</span><br><span class="line">     <span class="comment">// 2. 用模式匹配对元组元素赋值，实现功能</span></span><br><span class="line">    <span class="keyword">val</span> newList2 = list.map(</span><br><span class="line">      tuple =&gt; &#123;</span><br><span class="line">        tuple <span class="keyword">match</span> &#123;</span><br><span class="line">          <span class="keyword">case</span> (word, count) =&gt; (word, count * <span class="number">2</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">     <span class="comment">// 3. 省略lambda表达式的写法，进行简化</span></span><br><span class="line">    <span class="keyword">val</span> newList3 = list.map &#123;</span><br><span class="line">      <span class="keyword">case</span> (word, count) =&gt; (word, count * <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(newList3)</span><br><span class="line">     <span class="comment">// 偏函数的应用，求绝对值</span></span><br><span class="line">     <span class="comment">// 对输入数据分为不同的情形：正、负、0</span></span><br><span class="line">    <span class="keyword">val</span> positiveAbs: <span class="type">PartialFunction</span>[<span class="type">Int</span>, <span class="type">Int</span>] = &#123;</span><br><span class="line">      <span class="keyword">case</span> x <span class="keyword">if</span> x &gt; <span class="number">0</span> =&gt; x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> negativeAbs: <span class="type">PartialFunction</span>[<span class="type">Int</span>, <span class="type">Int</span>] = &#123;</span><br><span class="line">      <span class="keyword">case</span> x <span class="keyword">if</span> x &lt; <span class="number">0</span> =&gt; -x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> zeroAbs: <span class="type">PartialFunction</span>[<span class="type">Int</span>, <span class="type">Int</span>] = &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0</span> =&gt; <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">abs</span></span>(x: <span class="type">Int</span>): <span class="type">Int</span> = (positiveAbs orElse negativeAbs orElse zeroAbs) (x)</span><br><span class="line">    println(abs(<span class="number">-67</span>))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h2><p>当编译器第一次编译失败的时候，会在当前的环境中查找能让代码编译通过的方法，用于将类型进行转换，实现二次编译。隐式转换是 Scala 特有的功能，主要分为三种<strong>转换方式</strong>。</p><ul><li>隐式函数：隐式转换可以在不需改任何代码的情况下，扩展某个类的功能</li><li>隐式参数：普通方法或者函数中的参数可以通过 implicit 关键字声明为隐式参数，调用该方法时，就可以传入该参数，编译器会在相应的作用域寻找符合条件的隐式值。同一个作用域中，相同类型的隐式值只能有一个。编译器按照隐式参数的类型去寻找对应类型的隐式值，与隐式值的名称无关。隐式参数优先于默认参数。隐式参数参与的函数是一个柯里化函数，implicit关键字是应用到整个参数列表而不是单个参数的。</li><li>隐式类：其所带的构造参数有且只能有一个。必须被定义在“类”或“伴生对象”或“包对象”里，即隐式类不能是顶级的。</li></ul><p><strong>解析机制：</strong></p><ul><li>首先会在当前代码作用域下查找隐式实体（隐式方法、隐式类、隐式对象）。</li><li>如果第一条规则查找隐式实体失败，会继续在隐式参数的类型的作用域里查找。类型的作用域是指与该类型相关联的全部伴生对象以及该类型所在包的包对象。</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">     <span class="comment">// 首先会在当前代码作用域下查找隐式实体</span></span><br><span class="line">    <span class="keyword">val</span> teacher = <span class="keyword">new</span> <span class="type">Teacher</span>()</span><br><span class="line">    teacher.eat()</span><br><span class="line">    teacher.say()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">PersonTrait</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">PersonTrait</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果第一条规则查找隐式实体失败，会继续在隐式参数的类型的作用域里查找。类型的作用域是指与该类型相关联的全部伴生对象以及该类型所在包的包对象。</span></span><br><span class="line">  <span class="keyword">implicit</span> <span class="class"><span class="keyword">class</span> <span class="title">Person5</span>(<span class="params">user: <span class="type">Teacher</span></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">      println(<span class="string">&quot;say...&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">extends</span> <span class="title">PersonTrait</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">eat</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(<span class="string">&quot;eat...&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>Scala中的泛型与Java略有不同，除去默认的<strong>非变</strong>泛型格式外，还存在<strong>协变</strong>和<strong>逆变</strong>两种格式。此外，在 Scala 中泛型是有上界下界的，限定必须从哪个类继承、或者必须是哪个类的父类，具体示例如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// [T]</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Temp</span>[<span class="type">T</span>] </span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args:<span class="type">Array</span>[<span class="type">String</span>]):<span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> temp:<span class="type">Temp</span>[<span class="type">String</span>] = <span class="keyword">new</span> <span class="type">Temp</span>[<span class="type">String</span>]</span><br><span class="line">         <span class="comment">// 当泛型中的内容之间存在父子关系的时候，编译报错。</span></span><br><span class="line">        <span class="keyword">val</span> tempAny:<span class="type">Temp</span>[<span class="type">Any</span>] =temp</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// [+T]</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Temp</span>[+<span class="type">T</span>]</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args:<span class="type">Array</span>[<span class="type">String</span>]):<span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> temp:<span class="type">Temp</span>[<span class="type">String</span>] = <span class="keyword">new</span> <span class="type">Temp</span>[<span class="type">String</span>]</span><br><span class="line">         <span class="comment">// 泛型的子类和父类之间是可以进行多态关系的，父类引用可以指向子类的对象。如下的示例就是正确的。</span></span><br><span class="line">        <span class="keyword">val</span> tempAny:<span class="type">Temp</span>[<span class="type">Any</span>] = temp</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// [-T]</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Temp</span>[-<span class="type">T</span>]</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args:<span class="type">Array</span>[<span class="type">String</span>]):<span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> tempAny:<span class="type">Temp</span>[<span class="type">Any</span>] = <span class="keyword">new</span> <span class="type">Temp</span>[<span class="type">Any</span>]</span><br><span class="line">         <span class="comment">// 泛型的子类和父类之间是有关系的，泛型的子类引用可以指向泛型父类的对象，如下的示例就是正确的。</span></span><br><span class="line">        <span class="keyword">val</span> temp:<span class="type">Temp</span>[<span class="type">String</span>] = tempAny</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 上界定义语法 使用&lt;: 定义泛型，表示该泛型的参数必须要是该类型本身或者该类型的子类</span></span><br><span class="line">[<span class="type">T</span> &lt;: 类型]</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> [<span class="type">T</span>&lt;:<span class="type">Person</span>](<span class="params">a:<span class="type">T</span>,b:<span class="type">T</span></span>)</span>&#123;&#125;</span><br><span class="line"> <span class="comment">//下界定义语法 使用&gt;: 定义泛型，表示该泛型的参数必须是该类型的父类或者类型本身</span></span><br><span class="line">[<span class="type">T</span> &gt;: 类型]</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> [<span class="type">T</span> &gt;: <span class="type">Person</span>](<span class="params">a:<span class="type">T</span>,b:<span class="type">T</span></span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;模式匹配&quot;&gt;&lt;a href=&quot;#模式匹配&quot; class=&quot;headerlink&quot; title=&quot;模式匹配&quot;&gt;&lt;/a&gt;模式匹配&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;基本语法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;模式匹配语法中，采用 match 关键字声明，每个分支采用 ca</summary>
      
    
    
    
    <category term="学习" scheme="https://galaxy-ryan.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="大数据" scheme="https://galaxy-ryan.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    <category term="编程语言" scheme="https://galaxy-ryan.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://galaxy-ryan.github.io/article/2024/01/26/hello-word-hexo.html/"/>
    <id>https://galaxy-ryan.github.io/article/2024/01/26/hello-word-hexo.html/</id>
    <published>2024-01-26T04:00:00.000Z</published>
    <updated>2024-01-26T04:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    <category term="Other" scheme="https://galaxy-ryan.github.io/categories/Other/"/>
    
    
  </entry>
  
</feed>
